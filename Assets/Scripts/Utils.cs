//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Collections;
using Newtonsoft.Json;


namespace AssemblyCSharp
{
	public static class Utils
	{
		

		public static bool DeserializeFromFile<T> (string fileName, ref T objectToLoadDataInto) where T : class
		{
			if (File.Exists (fileName)) {//first confirm that the navmesh file exists
				using (Stream navmeshStream = File.OpenRead (fileName)) { //File.OpenRead opens the file with the read flag, rather than us having to set it. The using statement ensures that the created stream is cleaned up at the end of the block
					BinaryFormatter formatterForNavMesh = new BinaryFormatter ();
					objectToLoadDataInto = ((formatterForNavMesh.Deserialize (navmeshStream) as T));
					return true;
				}
				//return true;
			} else {
				return false;
			}
		}

		public static void SerializeToFile<T> (string fileName, ref T objectToLoadDataInto) where T : class
		{
			using (Stream stream = File.OpenWrite (fileName /*+ "_"+ ((int)(System.DateTime.Now.ToOADate()*1000))+ ".qsf"*/)) { //en sure that stream is cleaned up by creating it in a using statement - the stream will be cleaned up at the end of the using block
				//Debug.Log("Serializing tree!");
				BinaryFormatter formatter = new BinaryFormatter ();
				formatter.Serialize (stream, objectToLoadDataInto);
			}
		}

		public static void SerializeToFile<T> (string fileName, ref T objectToLoadDataInto, string extension) where T : class
		{
			using (Stream stream = File.OpenWrite (fileName /*+ "_"+ ((int)(System.DateTime.Now.ToOADate()*1000))*/ + extension)) { //en sure that stream is cleaned up by creating it in a using statement - the stream will be cleaned up at the end of the using block
				//Debug.Log("Serializing tree!");
				BinaryFormatter formatter = new BinaryFormatter ();
				formatter.Serialize (stream, objectToLoadDataInto);
			}
		}

		/// <summary>
		/// Serializes given object to JSON and writes JSON to file at path
		/// </summary>
		/// <param name="obj">Object.</param>
		/// <param name="path">Path.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public static void SerializeToFileJSON<T>(ref T obj, string path){
			string output = JsonConvert.SerializeObject(obj);
			File.WriteAllText (path, output);
		}

		/// <summary>
		/// Deserialize JSON in file at path and place the object
		/// in the given obj instance
		/// </summary>
		/// <param name="obj">Object.</param>
		/// <param name="path">Path.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public static void DeserializeFromFileJSON<T>(out T obj, string path){
			obj = JsonConvert.DeserializeObject<T>(File.ReadAllText(path));
		}

		/// <summary>
		/// XOR two arrays of ints by XORing the corresponding items
		/// </summary>
		/// <returns>The r integer.</returns>
		/// <param name="first">First.</param>
		/// <param name="second">Second.</param>
		public static int[] XOR_Integer (int[] first, int[] second)
		{
			int[] result = new int[first.Length];

			for (int i = 0; i < result.Length; ++i) {
				result [i] = first [i] ^ second [i];
			}

			return result;

		}

		/// <summary>
		/// AND two arrays of ints by ANDing the corresponding items
		/// </summary>
		/// <returns>The d integer.</returns>
		/// <param name="first">First.</param>
		/// <param name="second">Second.</param>
		public static int[] AND_Integer (int[] first, int[] second)
		{
			int[] result = new int[first.Length];
			
			for (int i = 0; i < result.Length; ++i) {
				result [i] = first [i] & second [i];
			}
			
			return result;
			
		}

		/// <summary>
		/// OR two arrays of ints by ORing the corresponding items
		/// </summary>
		/// <returns>The r integer.</returns>
		/// <param name="first">First.</param>
		/// <param name="second">Second.</param>
		public static int[] OR_Integer (int[] first, int[] second)
		{
			int[] result = new int[first.Length];
			
			for (int i = 0; i < result.Length; ++i) {
				result [i] = first [i] | second [i];
			}
			
			return result;
			
		}

		/// <summary>
		/// Get how many bits in the ints of the given array have value "1"
		/// </summary>
		/// <returns>The number of ones in binary string.</returns>
		/// <param name="str">String.</param>
		public static int GetNumberOfOnesInBinaryString (int[] str)
		{
			int result = 0;
			
			for (int i = 0; i < str.Length; ++i) {
				for (int j = 0; j < 32; j++) {
					if (0 < (str [i] & (1 << j)))
						++result;
				}
			}
			
			return result;
			
		}

		public delegate bool ConverterTU<T,U>(T input, out U output);

		/// <summary>
		/// Converts array of type T to array of type U, using the given
		/// conversion function to produce a new item of type U corresponding to a given item 
		/// of type T
		/// </summary>
		/// <returns>The array type.</returns>
		/// <param name="original">Original.</param>
		/// <param name="conversionFunc">Conversion func.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		/// <typeparam name="U">The 2nd type parameter.</typeparam>
		public static U[] ConvertArrayType<T,U>(T [] original, ConverterTU<T,U> conversionFunc){
			int o_c = original.Length;
			U[] result = new U[o_c];

			for (int i = 0; i < o_c; ++i) {
				U f;
				Debug.Assert (conversionFunc (original [i], out f));
				result [i] = f;
			}

			return result;
		}

		/// <summary>
		/// Tries to parse a string for a random float value.
		/// If the string is "R" a random value will be generated
		/// </summary>
		/// <returns><c>true</c>, if parse random value was tryed, <c>false</c> otherwise.</returns>
		/// <param name="s">S.</param>
		/// <param name="f">F.</param>
		public static bool TryParseRandomValue(string s, out float f){
			if (s.Equals ("R")) {
				f = UnityEngine.Random.value;
				return true;
			} else {
				return float.TryParse (s, out f);
			}
		}

		/// <summary>
		/// Randomly modifies a list in one of three ways:
		/// Removes a item with probability 0.15
		/// Adds a item with probability 0.66
		/// Replaces a item with probability 0.19
		/// </summary>
		/// <returns>The modified list.</returns>
		/// <param name="possibleAdditions">Possible additions.</param>
		/// <param name="originalList">Original list.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public static List<T> RandomlyModifyList<T> (List<T> possibleAdditions, List<T> originalList)
		{
			
			List<T> result = new List<T> (originalList);

			if (possibleAdditions.Count == 0) {
				return result;
			}

			float r_val = UnityEngine.Random.value;
			if (r_val < 0.15f && originalList.Count > 1) {

				int node1 = UnityEngine.Random.Range (0, possibleAdditions.Count);
				result.Remove (possibleAdditions [node1]);


			} else if (r_val < 0.66f) {
				List<T> possibleAdditions_copy = new List<T>(possibleAdditions);
				possibleAdditions_copy  = ShuffleList (possibleAdditions_copy );
				for (int i = 0; i < possibleAdditions_copy.Count ; ++i) {
					if (!result.Contains (possibleAdditions_copy [i])) {
						result.Add (possibleAdditions_copy [i]);
						break;
					}
				}
			} else {
				int node1 = UnityEngine.Random.Range (0, result.Count);
				int node2 = UnityEngine.Random.Range (0, possibleAdditions.Count);
				if (!result.Contains (possibleAdditions [node2])) {
					result [node1] = possibleAdditions [node2];
				}
			}
			return result;
		}

		/// <summary>
		/// Randomly modifies a list in one of three ways:
		/// Removes a item with probability 0.15
		/// Adds a item with probability 0.66
		/// Replaces a item with probability 0.19
		/// The constraint mapping defines what pairs of items cannot occur in the final list
		/// </summary>
		/// <returns>The modified list filter invalid lists.</returns>
		/// <param name="possibleAdditions">Possible additions.</param>
		/// <param name="originalList">Original list.</param>
		/// <param name="constraints">Constraints.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public static List<T> RandomlyModifyList_FilterInvalidLists<T> (List<T> possibleAdditions, List<T> originalList, ConstraintMapping constraints)
		{
			string debug = "debug";
			Debug.Assert (debug.ToString ().Equals (debug));
			List<T> possibleAdditions_shuffled = ShuffleList<T> (possibleAdditions);

			List<T> result = new List<T> (originalList);

			if (possibleAdditions.Count == 0) {
				return result;
			}

			float r_val = UnityEngine.Random.value;
			if (r_val < 0.15f && originalList.Count > 1) {

				for (int i = 0; i < possibleAdditions_shuffled.Count; ++i) {
				
					if (result.Contains (possibleAdditions_shuffled [i])) {
						result.Remove (possibleAdditions_shuffled [i]);
						break;
					}
				}


			} else if (r_val < 0.66f) {
				//List<T> possibleAdditions_copy = new List<T>(possibleAdditions_shuffled);
				//possibleAdditions_copy  = ShuffleList (possibleAdditions_copy );
				for (int i = 0; i < possibleAdditions_shuffled.Count ; ++i) {
					if (!result.Contains (possibleAdditions_shuffled [i])) {
						//check for constraint
						bool noCostraint = true;
						for (int j = 0; j < result.Count; ++j) {
							if (constraints.GetConstraint (result [j].ToString(), possibleAdditions_shuffled [i].ToString())) {
								noCostraint = false;
								break;
							}
						}

						if (!noCostraint) {
							continue;
						}

						result.Add (possibleAdditions_shuffled [i]);
						break;
					}
				}
			} else {
				int node1 = UnityEngine.Random.Range (0, result.Count);
				int node2 = UnityEngine.Random.Range (0, possibleAdditions.Count);
				for (int i = 0; i < possibleAdditions_shuffled.Count; ++i) {
					if (!result.Contains (possibleAdditions [node2])) {
						bool noCostraint = true;
						for (int j = 0; j < result.Count; ++j) {
							if (j == node1) {
								continue; //if the new item would conflict with the item it is going to replace, it doesn't matter
							}
							if (constraints.GetConstraint (result [j].ToString (), possibleAdditions_shuffled [i].ToString())) {
								noCostraint = false;
								break;
							}
						}

						if (!noCostraint) {
							continue;
						}

						result [node1] = possibleAdditions [node2];
						break;
					}
				}
			}
			return result;
		}

		/// <summary>
		/// Shuffles the given list
		/// </summary>
		/// <returns>A new, shuffled list.</returns>
		/// <param name="input">Input.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public static List<T> ShuffleList<T> (List<T> input)
		{
			List<T> result = new List<T> ();
			result.AddRange (input);
			for (int i = 0; i < result.Count; ++i) {
				int randomIndex = UnityEngine.Random.Range (0, result.Count - 1);
				T temp = result [randomIndex];
				result [randomIndex] = result [i];
				result [i] = temp;
			}
			return result;
		}

		/// <summary>
		/// Shuffles the array.
		/// </summary>
		/// <returns>A new, shuffled array</returns>
		/// <param name="input">Input.</param>
		/// <typeparam name="T">The 1st type parameter.</typeparam>
		public static T[] ShuffleArray<T> (T[] input)
		{
			int i_l = input.Length;
			T[] result = new T [i_l];

			for (int i = 0; i < i_l; ++i) {
				result [i] = input [i];
			}

			for (int i = 0; i < result.Length; ++i) {
				int randomIndex = UnityEngine.Random.Range (0, result.Length - 1);
				T temp = result [randomIndex];
				result [randomIndex] = result [i];
				result [i] = temp;
			}
			return result;
		}

		/// <summary>
		/// Get standard deviation of a set of float values
		/// </summary>
		/// <returns>The deviation.</returns>
		/// <param name="data">Data.</param>
		public static float StandardDeviation(float[] data)
		{
			float stdDev = 0;
			float sumAll = 0;
			float sumAllQ = 0;

			//Sum of x and sum of x²
			for (int i = 0; i < data.Length; i++)
			{
				float x = data[i];
				sumAll += x;
				sumAllQ += x * x;
			}

			//Mean (not used here)
			//double mean = 0;
			//mean = sumAll / (double)data.Length;

			//Standard deviation
			stdDev = Mathf.Sqrt(
				(sumAllQ -
					(sumAll * sumAll) / data.Length) *
				(1.0f / (data.Length - 1))
			);

			return stdDev;
		}

		/// <summary>
		/// Compare two floats with the comparison depending
		/// on the given operation
		/// </summary>
		/// <param name="a">The alpha component.</param>
		/// <param name="b">The blue component.</param>
		/// <param name="op">Op.</param>
		public static bool Compare(float a, float b, ComparisonOperator op){
			if (op == ComparisonOperator.LT){
				return a<b;
			} else if (op == ComparisonOperator.LE){
				return a<=b;
			} else if (op == ComparisonOperator.EQ){
				return a==b;
			}else if (op == ComparisonOperator.NE){
				return a!=b;
			}else if (op == ComparisonOperator.GE){
				return a>=b;
			}else {
				return a>b;
			}
		}
	}

	[Serializable]
	public class Pair<T,U>
	{
		public T first;
		public U second;

		public Pair (T first, U second)
		{
			this.first = first;
			this.second = second;
		}

		//		public int Equals(Pair<T,U> other){
		//			return this.first.Equals (other.first);
		//		}
	}

	[Serializable]
	/// <summary>
	/// Represents mapping of a string to a float
	/// </summary>
	public class StringFloatMap : Pair<string,float>
	{
		public StringFloatMap (string s, float f) : base (s, f)
		{

		}
	}

	[Serializable]
	public class FloatRange{
		public string label;
		public float min;
		public float max;

		public FloatRange(string label, float min, float max){
			Debug.Assert (max >= min);
			this.label = label;
			this.min = min;
			this.max = max;
		}

		public static FloatRange [] ToFloatRange(IEnumerable<float> l1, IEnumerable<float> l2){
			float[] fl1 = l1.ToArray ();
			float[] fl2 = l2.ToArray ();
			Debug.Assert (fl1.Length == fl2.Length);
			FloatRange[] result = new FloatRange[fl1.Length];
			int f_l = fl1.Length;
			for (int i = 0; i < f_l; ++i) {
				result [i] = new FloatRange ("", fl1 [i], fl2 [i]);
			}

			return result;
		}
	}

	public class GameObjectComparer : IComparer<GameObject>{
		int IComparer<GameObject>.Compare(GameObject a, GameObject b){
			return a.ToString().CompareTo (b.ToString());
		}
	}
}

