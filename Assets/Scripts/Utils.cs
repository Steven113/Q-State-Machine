//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Collections;


namespace AssemblyCSharp
{
	public static class Utils
	{
		static Utils(){
			//old seed: 5145636
			//old seed: 758215
			//old seed: 158215
			//old seed: 3514852
			//old seed: 845
			//old seed: 12846
			//old seed: 6845274
			UnityEngine.Random.InitState (3354);
		}

		public static bool DeserializeFile<T> (string fileName, ref T objectToLoadDataInto) where T : class
		{
			if (File.Exists (fileName)) {//first confirm that the navmesh file exists
				using (Stream navmeshStream = File.OpenRead (fileName)) { //File.OpenRead opens the file with the read flag, rather than us having to set it. The using statement ensures that the created stream is cleaned up at the end of the block
					BinaryFormatter formatterForNavMesh = new BinaryFormatter ();
					objectToLoadDataInto = ((formatterForNavMesh.Deserialize (navmeshStream) as T));
					return true;
				}
				//return true;
			} else {
				return false;
			}
		}

		public static void SerializeFile<T> (string fileName, ref T objectToLoadDataInto) where T : class
		{
			using (Stream stream = File.OpenWrite (fileName /*+ "_"+ ((int)(System.DateTime.Now.ToOADate()*1000))+ ".qsf"*/)) { //en sure that stream is cleaned up by creating it in a using statement - the stream will be cleaned up at the end of the using block
				//Debug.Log("Serializing tree!");
				BinaryFormatter formatter = new BinaryFormatter ();
				formatter.Serialize (stream, objectToLoadDataInto);
			}
		}

		public static void SerializeFile<T> (string fileName, ref T objectToLoadDataInto, string extension) where T : class
		{
			using (Stream stream = File.OpenWrite (fileName /*+ "_"+ ((int)(System.DateTime.Now.ToOADate()*1000))*/ + extension)) { //en sure that stream is cleaned up by creating it in a using statement - the stream will be cleaned up at the end of the using block
				//Debug.Log("Serializing tree!");
				BinaryFormatter formatter = new BinaryFormatter ();
				formatter.Serialize (stream, objectToLoadDataInto);
			}
		}

		public static int[] XOR_Integer (int[] first, int[] second)
		{
			int[] result = new int[first.Length];

			for (int i = 0; i < result.Length; ++i) {
				result [i] = first [i] ^ second [i];
			}

			return result;

		}

		public static int[] AND_Integer (int[] first, int[] second)
		{
			int[] result = new int[first.Length];
			
			for (int i = 0; i < result.Length; ++i) {
				result [i] = first [i] & second [i];
			}
			
			return result;
			
		}

		public static int[] OR_Integer (int[] first, int[] second)
		{
			int[] result = new int[first.Length];
			
			for (int i = 0; i < result.Length; ++i) {
				result [i] = first [i] | second [i];
			}
			
			return result;
			
		}

		public static int GetNumberOfOnesInBinaryString (int[] str)
		{
			int result = 0;
			
			for (int i = 0; i < str.Length; ++i) {
				for (int j = 0; j < 32; j++) {
					if (0 < (str [i] & (1 << j)))
						++result;
				}
			}
			
			return result;
			
		}

		public delegate bool ConverterTU<T,U>(T input, out U output);

		public static U[] ConvertArrayType<T,U>(T [] original, ConverterTU<T,U> conversionFunc){
			int o_c = original.Length;
			U[] result = new U[o_c];

			for (int i = 0; i < o_c; ++i) {
				U f;
				Debug.Assert (conversionFunc (original [i], out f));
				result [i] = f;
			}

			return result;
		}

		public static bool TryParseR(string s, out float f){
			if (s.Equals ("R")) {
				f = UnityEngine.Random.value;
				return true;
			} else {
				return float.TryParse (s, out f);
			}
		}

		public static List<T> RandomlyModifyList<T> (List<T> possibleAdditions, List<T> originalList)
		{
			
			List<T> result = new List<T> (originalList);

			if (possibleAdditions.Count == 0) {
				return result;
			}

			float r_val = UnityEngine.Random.value;
			if (r_val < 0.15f && originalList.Count > 1) {

				int node1 = UnityEngine.Random.Range (0, possibleAdditions.Count);
				result.Remove (possibleAdditions [node1]);


			} else if (r_val < 0.66f) {
				List<T> possibleAdditions_copy = new List<T>(possibleAdditions);
				possibleAdditions_copy  = ShuffleList (possibleAdditions_copy );
				for (int i = 0; i < possibleAdditions_copy.Count ; ++i) {
					if (!result.Contains (possibleAdditions_copy [i])) {
						result.Add (possibleAdditions_copy [i]);
						break;
					}
				}
			} else {
				int node1 = UnityEngine.Random.Range (0, result.Count);
				int node2 = UnityEngine.Random.Range (0, possibleAdditions.Count);
				if (!result.Contains (possibleAdditions [node2])) {
					result [node1] = possibleAdditions [node2];
				}
			}
			return result;
		}

		public static List<T> RandomlyModifyList_FilterInvalidLists<T> (List<T> possibleAdditions, List<T> originalList, ConstraintMapping constraints)
		{
			string debug = "debug";
			Debug.Assert (debug.ToString ().Equals (debug));
			List<T> possibleAdditions_shuffled = ShuffleList<T> (possibleAdditions);

			List<T> result = new List<T> (originalList);

			if (possibleAdditions.Count == 0) {
				return result;
			}

			float r_val = UnityEngine.Random.value;
			if (r_val < 0.15f && originalList.Count > 1) {

				for (int i = 0; i < possibleAdditions_shuffled.Count; ++i) {
				
					if (result.Contains (possibleAdditions_shuffled [i])) {
						result.Remove (possibleAdditions_shuffled [i]);
						break;
					}
				}


			} else if (r_val < 0.66f) {
				//List<T> possibleAdditions_copy = new List<T>(possibleAdditions_shuffled);
				//possibleAdditions_copy  = ShuffleList (possibleAdditions_copy );
				for (int i = 0; i < possibleAdditions_shuffled.Count ; ++i) {
					if (!result.Contains (possibleAdditions_shuffled [i])) {
						//check for constraint
						bool noCostraint = true;
						for (int j = 0; j < result.Count; ++j) {
							if (constraints.GetConstraint (result [j].ToString(), possibleAdditions_shuffled [i].ToString())) {
								noCostraint = false;
								break;
							}
						}

						if (!noCostraint) {
							continue;
						}

						result.Add (possibleAdditions_shuffled [i]);
						break;
					}
				}
			} else {
				int node1 = UnityEngine.Random.Range (0, result.Count);
				int node2 = UnityEngine.Random.Range (0, possibleAdditions.Count);
				for (int i = 0; i < possibleAdditions_shuffled.Count; ++i) {
					if (!result.Contains (possibleAdditions [node2])) {
						bool noCostraint = true;
						for (int j = 0; j < result.Count; ++j) {
							if (j == node1) {
								continue; //if the new item would conflict with the item it is going to replace, it doesn't matter
							}
							if (constraints.GetConstraint (result [j].ToString (), possibleAdditions_shuffled [i].ToString())) {
								noCostraint = false;
								break;
							}
						}

						if (!noCostraint) {
							continue;
						}

						result [node1] = possibleAdditions [node2];
						break;
					}
				}
			}
			return result;
		}

		public static List<T> ShuffleList<T> (List<T> input)
		{
			List<T> result = new List<T> ();
			result.AddRange (input);
			for (int i = 0; i < result.Count; ++i) {
				int randomIndex = UnityEngine.Random.Range (0, result.Count - 1);
				T temp = result [randomIndex];
				result [randomIndex] = result [i];
				result [i] = temp;
			}
			return result;
		}

		public static T[] ShuffleArray<T> (T[] input)
		{
			int i_l = input.Length;
			T[] result = new T [i_l];

			for (int i = 0; i < i_l; ++i) {
				result [i] = input [i];
			}

			for (int i = 0; i < result.Length; ++i) {
				int randomIndex = UnityEngine.Random.Range (0, result.Length - 1);
				T temp = result [randomIndex];
				result [randomIndex] = result [i];
				result [i] = temp;
			}
			return result;
		}

		public static float StandardDeviation(float[] data)
		{
			float stdDev = 0;
			float sumAll = 0;
			float sumAllQ = 0;

			//Sum of x and sum of xÂ²
			for (int i = 0; i < data.Length; i++)
			{
				float x = data[i];
				sumAll += x;
				sumAllQ += x * x;
			}

			//Mean (not used here)
			//double mean = 0;
			//mean = sumAll / (double)data.Length;

			//Standard deviation
			stdDev = Mathf.Sqrt(
				(sumAllQ -
					(sumAll * sumAll) / data.Length) *
				(1.0f / (data.Length - 1))
			);

			return stdDev;
		}

		public static bool Compare(float a, float b, ComparisonOperator op){
			if (op == ComparisonOperator.LT){
				return a<b;
			} else if (op == ComparisonOperator.LE){
				return a<=b;
			} else if (op == ComparisonOperator.EQ){
				return a==b;
			}else if (op == ComparisonOperator.NE){
				return a!=b;
			}else if (op == ComparisonOperator.GE){
				return a>=b;
			}else {
				return a>b;
			}
		}
	}

	[Serializable]
	public class Pair<T,U>
	{
		public T first;
		public U second;

		public Pair (T first, U second)
		{
			this.first = first;
			this.second = second;
		}

		//		public int Equals(Pair<T,U> other){
		//			return this.first.Equals (other.first);
		//		}
	}

	[Serializable]
	public class StringFloatMap : Pair<string,float>
	{
		public StringFloatMap (string s, float f) : base (s, f)
		{

		}
	}

	[Serializable]
	public class FloatRange{
		public string label;
		public float min;
		public float max;

		public FloatRange(string label, float min, float max){
			Debug.Assert (max >= min);
			this.label = label;
			this.min = min;
			this.max = max;
		}

		public static FloatRange [] ToFloatRange(IEnumerable<float> l1, IEnumerable<float> l2){
			float[] fl1 = l1.ToArray ();
			float[] fl2 = l2.ToArray ();
			Debug.Assert (fl1.Length == fl2.Length);
			FloatRange[] result = new FloatRange[fl1.Length];
			int f_l = fl1.Length;
			for (int i = 0; i < f_l; ++i) {
				result [i] = new FloatRange ("", fl1 [i], fl2 [i]);
			}

			return result;
		}
	}

	public class GameObjectComparer : IComparer<GameObject>{
		int IComparer<GameObject>.Compare(GameObject a, GameObject b){
			return a.ToString().CompareTo (b.ToString());
		}
	}
}

