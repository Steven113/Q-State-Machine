//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	public static class Utils
	{
		public static bool DeserializeFile<T>(string fileName, ref T objectToLoadDataInto) where T : class {
			if (File.Exists (fileName)) {//first confirm that the navmesh file exists
				using (Stream navmeshStream = File.OpenRead(fileName)){ //File.OpenRead opens the file with the read flag, rather than us having to set it. The using statement ensures that the created stream is cleaned up at the end of the block
					BinaryFormatter formatterForNavMesh = new BinaryFormatter();
					objectToLoadDataInto = ((formatterForNavMesh.Deserialize(navmeshStream) as T));
					return true;
				}
				//return true;
			} else {
				return false;
			}
		}

		public static void SerializeFile<T>(string fileName, ref T objectToLoadDataInto) where T : class {
			using (Stream stream = File.OpenWrite(fileName /*+ "_"+ ((int)(System.DateTime.Now.ToOADate()*1000))+ ".qsf"*/) ) //en sure that stream is cleaned up by creating it in a using statement - the stream will be cleaned up at the end of the using block
			{
				//Debug.Log("Serializing tree!");
				BinaryFormatter formatter = new BinaryFormatter();
				formatter.Serialize(stream, objectToLoadDataInto);
			}
		}

		public static void SerializeFile<T>(string fileName, ref T objectToLoadDataInto, string extension) where T : class {
			using (Stream stream = File.OpenWrite(fileName /*+ "_"+ ((int)(System.DateTime.Now.ToOADate()*1000))*/+extension) ) //en sure that stream is cleaned up by creating it in a using statement - the stream will be cleaned up at the end of the using block
			{
				//Debug.Log("Serializing tree!");
				BinaryFormatter formatter = new BinaryFormatter();
				formatter.Serialize(stream, objectToLoadDataInto);
			}
		}

		public static int[] XOR_Integer(int[] first, int[] second) 
		{
			int [] result = new int[first.Length];

			for (int i = 0; i<result.Length; ++i) {
				result[i] = first[i] ^ second[i];
			}

			return result;

		}

		public static int[] AND_Integer(int[] first, int[] second) 
		{
			int [] result = new int[first.Length];
			
			for (int i = 0; i<result.Length; ++i) {
				result[i] = first[i] & second[i];
			}
			
			return result;
			
		}

		public static int[] OR_Integer(int[] first, int[] second) 
		{
			int [] result = new int[first.Length];
			
			for (int i = 0; i<result.Length; ++i) {
				result[i] = first[i] | second[i];
			}
			
			return result;
			
		}

		public static int GetNumberOfOnesInBinaryString(int[] str) 
		{
			int result = 0;
			
			for (int i = 0; i<str.Length; ++i) {
				for (int j = 0; j<32; j++){
					if (0<(str[i] & (1<<j))) ++result;
				}
			}
			
			return result;
			
		}

		public static List<T> ShuffleArray<T>(List<T> input){
			List<T> result = new List<T> ();
			result.AddRange (input);
			for (int i = 0; i<result.Count; ++i) {
				int randomIndex = UnityEngine.Random.Range(0,result.Count-1);
				T temp = result [randomIndex];
				result[randomIndex] = result[i];
				result[i] = temp;
			}
			return result;
		}

		public static T[] ShuffleArray<T>(T[] input){
			int i_l = input.Length;
			T[] result = new T [i_l];

			for (int i = 0; i < i_l; ++i) {
				result [i] = input [i];
			}

			for (int i = 0; i<result.Length; ++i) {
				int randomIndex = UnityEngine.Random.Range(0,result.Length-1);
				T temp = result [randomIndex];
				result[randomIndex] = result[i];
				result[i] = temp;
			}
			return result;
		}
	}
}

