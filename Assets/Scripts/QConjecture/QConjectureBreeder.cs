//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	/*
	 * Given a list of learners, waits for them to learn enough examples, then takes the best performing conjectures, combines them, and assigns them back to all the learners
	 */
	public class QConjectureBreeder : MonoBehaviour
	{
		public int numExamplesToRunBeforeBreeding = 600;
		public List<QConjectureAgent> learnersToBreed = new List<QConjectureAgent>();
		//public List<QSoldier> agentsToCheck = new List<QSoldier>();
		

		void Update(){
			for (int i = 0; i<learnersToBreed.Count; ++i) {
				if (learnersToBreed[i].learner.numExamplesRun>=numExamplesToRunBeforeBreeding){
					BreedLearners();
				}
			}
		}

		void BreedLearners(){
			Debug.Log("Breeding!");
			float [] fitnessValuesByLearner = new float[learnersToBreed.Count];
			NodeList<QConjectureMap> []  conceptLearnerConjecturesByFitness = new NodeList<QConjectureMap>[learnersToBreed.Count];
			float totalFitness = 0;
			for (int i = 0; i<learnersToBreed.Count; ++i) {
				if (learnersToBreed[i].enabled == false) continue;
				conceptLearnerConjecturesByFitness[i] = new NodeList<QConjectureMap>();
				conceptLearnerConjecturesByFitness[i].AddAll(learnersToBreed[i].learner.conjectures);
				int exRunNum = learnersToBreed[i].learner.numExamplesRun;
				fitnessValuesByLearner[i] = learnersToBreed[i].learner.TotalFitness/(exRunNum>0?exRunNum:numExamplesToRunBeforeBreeding); //different learners could have executed different numbers of exampels, so we must take average fitness gained per example
				totalFitness+=fitnessValuesByLearner[i];
			}
			NodeList<QConjectureMap> conjecturesToBreed = new NodeList<QConjectureMap> ();

			for (int i = 0; i<learnersToBreed.Count; ++i) {
				if (learnersToBreed[i].enabled == false) continue;
				int limit = Mathf.RoundToInt(learnersToBreed[i].learner.conjectures.Count*(fitnessValuesByLearner[i]/totalFitness));
				Debug.Log("Learner "+i+ " will contribute "+limit+"conjectures");
				for (int j = 0; j<limit; ++j){
					conjecturesToBreed.Add(conceptLearnerConjecturesByFitness[i][j]);
				}
			}

			Debug.Log ("The conjectures were combined to yield "+conjecturesToBreed.Count+ " conjectures");

			for (int i = 0; i<learnersToBreed.Count; ++i) {
				if (learnersToBreed[i].enabled == false) continue;
				Debug.Log("Learner: "+learnersToBreed[i].gameObject.name);
				learnersToBreed[i].learner.GenerateBaseConjectures(false);
				learnersToBreed[i].learner.conjectures.AddRange(conjecturesToBreed.toList());
				learnersToBreed[i].learner.numExamplesRun = 0;
				learnersToBreed[i].learner.CurrentGeneration+=1;
				//learnersToBreed[i].learner.Evolve();
				int limit = learnersToBreed[i].learner.conjectures.Count;
				for (int j = ((i/learnersToBreed.Count)*limit); j<(((i+1)/learnersToBreed.Count)*limit); ++j){
					learnersToBreed[i].learner.conjectures.AddRange(learnersToBreed[i].learner.SpecializeConjecture(learnersToBreed[i].learner.conjectures[j%limit]));
				}
				for (int j = 0 ; j<learnersToBreed[i].learner.conjectures.Count; ++j){
					learnersToBreed[i].learner.conjectures[j].timeWhenConjectureWasLastSelected = Time.time;
					learnersToBreed[i].learner.conjectures[j].fitness = 0;
				}
				//learnersToBreed[i].learner.ResetTimers();
				//learnersToBreed[i].learner.ResetFitness();
			}
		}
	}
}

