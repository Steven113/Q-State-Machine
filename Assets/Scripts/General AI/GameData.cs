//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Collections.ObjectModel;


namespace AssemblyCSharp
{
    [Serializable]
    public static class GameData
    {
        public static Weapon[] baseWeapons = null;
        //public static FactionRelation[,] factionRelations = new FactionRelation[2,2]; //factionRelations [i][j] is the relationship between faction i and faction j is the relationship between faction i and faction j
        //public static Dictionary<Collider,SoldierEntity> colliderToSoldierMap = new Dictionary<Collider,SoldierEntity>();//used to enable fast look ups of which soldier has been spotted/hurt
        public static Collection<Faction> Factions = new Collection<Faction>();
        public static Dictionary<Collider, ControlHealth> SuppressionSphereDictionary = new Dictionary<Collider, ControlHealth>();
		public static Dictionary<FactionName,int> scores = new Dictionary<FactionName, int>(); //score array for AI factions
        public static List<Vector3> Spawnpoints = new List<Vector3>(); //spawnpoints for respawning
        public static List<GameObject> mapBoundaries = new List<GameObject>();
        //public static float mapWidth = 0f;
		public static int numSoldierAlive = 0;
		public static Dictionary<FactionName,float> damageMultipliers = new Dictionary<FactionName,float>();
		public static Dictionary<FactionName,float> armourMultipliers = new Dictionary<FactionName,float >();
		public static Dictionary<FactionName,float> factionSpreadMultipliers = new Dictionary<FactionName,float >();

       
        //add a entity to a faction. If a faction doesn't exist for the entity, the function creates one and returns true to indicate that a faction was created
        public static bool addEntity(SoldierEntity entity)
        {
            for (int i = 0; i < Factions.Count; i++)
            {
                if (Factions[i].FactionName == entity.faction)
                {
                    Factions[i].Soldiers.Add(entity);
                    //for (int j = 0; j<FactionName[i].Soldiers.Count; j++){
                    //	FactionName[i].Soldiers[j].knownPositionsOfOtherSoldiers.Add(new SoldierIntel(entity,Vector3.zero));
                    //}
                    for (int j = 0; j < Factions.Count; j++)
                    {
                        if (Factions[j].FactionName != entity.faction)
                        {
                            Factions[j].SoldierIntelData.Add(new SoldierIntel(entity));
                        }
                    }
                    return true;
                }// else {

                //}
            }
            Factions.Add(new Faction(entity.faction));
            Factions[Factions.Count - 1].Soldiers.Add(entity);
            //	for (int j = 0; j<FactionName[FactionName.Count - 1].Soldiers.Count; j++){
            //		FactionName[FactionName.Count - 1].Soldiers[j].knownPositionsOfOtherSoldiers.Add(new SoldierIntel(entity,Vector3.zero));
            //}
            for (int j = 0; j < Factions.Count - 1; j++)
            {
                Factions[j].SoldierIntelData.Add(new SoldierIntel(entity));
            }

            for (int i = 0; i < Factions.Count; i++)
            {

                for (int k = 0; k < Factions[i].Soldiers.Count; k++)
                {
                    for (int j = 0; j < Factions.Count; j++)
                    {
                        if (Factions[i] != Factions[j])
                        {
                            bool hasIntel = false;
                            for (int l = 0; l < Factions[j].SoldierIntelData.Count; l++)
                            {
                                if (Factions[j].SoldierIntelData[l].soldierEntityToTrack == Factions[i].Soldiers[k])
                                {
                                    hasIntel = true;
                                    break;
                                }
                            }
                            if (!hasIntel)
                            {
                                Factions[j].SoldierIntelData.Add(new SoldierIntel(Factions[i].Soldiers[k]));
                            }
                        }
                    }
                    Factions[Factions.Count - 1].SoldierIntelData.Add(new SoldierIntel(Factions[i].Soldiers[k]));
                }
                //}
            }

            return true;
        }

        public static Collection<Faction> GetFactionName
        {
            get
            {
                return Factions;
            }
        }

        public static int getNumEnemyEntities(FactionName faction)
        {
            int result = 0;
            for (int i = 0; i < Factions.Count; i++)
            {
                if (Factions[i].FactionName != faction)
                {
                    result += Factions[i].Soldiers.Count;
                }
            }
            return result;
        }

        public static Faction getFaction(FactionName factionToGet)
        {
            for (int i = 0; i < Factions.Count; i++)
            {
                if (Factions[i].FactionName == factionToGet)
                {
                    return Factions[i];
                }
            }
            Factions.Add(new Faction(factionToGet));
            return Factions[Factions.Count - 1];
        }

       
        public static void RemoveSoldier(SoldierEntity entity)
        {
            getFaction(entity.faction).Soldiers.Remove(entity);
            for (int i = 0; i < Factions.Count; ++i)
            {
                for (int k = 0; k < Factions[i].SoldierIntelData.Count; k++)
                {
                    if (Factions[i].SoldierIntelData[k].soldierEntityToTrack == entity)
                    {
                        Factions[i].SoldierIntelData.RemoveAt(k);
                        --k;
                    }
                }
            }
        }

		public static FactionName [] ActiveFactions(){
			FactionName[] activeFactions = new FactionName[Factions.Count];
			for (int i = 0; i < Factions.Count; ++i) {
				activeFactions [i] = Factions [i].FactionName;
			}
			return activeFactions;
		}
    }
}

