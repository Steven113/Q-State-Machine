//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	[Serializable]
	public class FireMode
	{
		//static UnityEngine.Random random;
		public string name = "";
		public float fireRate = 0.25f;
		public float muzzleVelocity = 10;
		//public Vector2 xzDeviance = new Vector2(1,1); //worst case deviation
		public float devianceRadius = 1;
		public GameObject projectileToGenerate;
		public GameObject tracerProjectileToGenerate;
		public int numShotsPerBurst = 1;
		public float timeSinceLastShot = float.PositiveInfinity;
		public float aimingFov = 30;
		Vector3 randomisedOffset = Vector3.zero;
		public float minimumDeviationMultiplier = 0.1f;
		public float deviationMultiplier = 0.1f;
		public float maximumDeviationMultiplier = 1f;
		public float deltaDeviationMultiplier = 0.1f; //how much deviation multiplier increases when firing, or decreases per second
		public float aimingDeviationMultiplier = 1f;
		public bool fireFromEndOfBarrel = false;
		public bool willFireIfButtonHeldDown = true;
		public bool willFireIfButtonTapped = true;
		public float airStabilization = 0.25f;
		public int tracerFrequency = 5;
		public int numBulletsFired = 0;
		public bool isHoming = false;
		public static Transform transformToLockOnto;

		public FireMode(string name, float muzzleVelocity, float devianceRadius, GameObject projectileToGenerate, int numShotsPerBurst, float aimingFov, float minimumDeviationMultiplier, float deviationMultiplier, float maximumDeviationMultiplier,float deltaDeviationMultiplier, bool willFireIfButtonHeldDown, bool willFireIfButtonTapped){
			this.name = name;
			this.muzzleVelocity = muzzleVelocity;
			//this.xzDeviance = xzDeviance;
			this.devianceRadius = devianceRadius;
			this.projectileToGenerate = projectileToGenerate;
			this.numShotsPerBurst = numShotsPerBurst;
			this.aimingFov = aimingFov;
			this.minimumDeviationMultiplier = minimumDeviationMultiplier;
			this.deviationMultiplier = deviationMultiplier;
			this.maximumDeviationMultiplier = maximumDeviationMultiplier;
			this.deltaDeviationMultiplier = deltaDeviationMultiplier;
			this.willFireIfButtonHeldDown = willFireIfButtonHeldDown;
			this.willFireIfButtonTapped = willFireIfButtonTapped;
		}

		//takes barrelEnd and barrelStart in world coordinates
		public int fire(Vector3 barrelEnd, Vector3 barrelStart, int numBulletsInMag, FactionName factionThatFiredShot,  bool isAiming = false){ //returns whether weapon needs to reload.
			int numBulletsFired = 0;
			//Debug.Log ("Firemode firing!");
			if (timeSinceLastShot > fireRate) {
				Debug.Assert(timeSinceLastShot>fireRate);
				for (int i = 0; i< numShotsPerBurst && numBulletsFired<numBulletsInMag; i++) {
					++numBulletsFired;
					if (isAiming){
						randomisedOffset.x = UnityEngine.Random.insideUnitCircle.x*devianceRadius * deviationMultiplier * aimingDeviationMultiplier;;
						randomisedOffset.y = UnityEngine.Random.insideUnitCircle.y * devianceRadius * deviationMultiplier * aimingDeviationMultiplier;;
					}
					else {
						randomisedOffset.x = UnityEngine.Random.insideUnitCircle.x*devianceRadius * deviationMultiplier;
						randomisedOffset.y = Mathf.Abs(UnityEngine.Random.insideUnitCircle.y * devianceRadius * deviationMultiplier);
					}
					Vector3 projectileSpawnPoint = Vector3.zero;
					if (fireFromEndOfBarrel){
						projectileSpawnPoint = (barrelEnd + Quaternion.LookRotation (barrelEnd - barrelStart, Vector3.up)*randomisedOffset);
					} else{
						projectileSpawnPoint = (barrelStart + Quaternion.LookRotation (barrelEnd - barrelStart, Vector3.up)*randomisedOffset);
					}
					GameObject temp = null;
					if (numBulletsFired%tracerFrequency==0){
						temp = (GameObject)GameObject.Instantiate (tracerProjectileToGenerate, projectileSpawnPoint, Quaternion.LookRotation (barrelEnd - barrelStart, Vector3.up));
					} else {
						temp = (GameObject)GameObject.Instantiate (projectileToGenerate, projectileSpawnPoint, Quaternion.LookRotation (barrelEnd - barrelStart, Vector3.up));
					}
						//implement setting direction of projectile
					temp.GetComponent<ProjectileScript>().direction = ((barrelEnd + randomisedOffset) - barrelStart).normalized;
					temp.GetComponent<ProjectileScript>().speed = muzzleVelocity;
					temp.GetComponent<ProjectileScript>().factionThatFiredShot = factionThatFiredShot;
					temp.GetComponent<ProjectileScript>().airStabilisation = airStabilization;
					deviationMultiplier += deltaDeviationMultiplier;
					deviationMultiplier = Mathf.Min(deviationMultiplier,maximumDeviationMultiplier);
					if (isHoming){
						if (temp.GetComponent<HomingGrenadeProjectile>()!=null){
							temp.GetComponent<HomingGrenadeProjectile>().transformToMoveTowards = transformToLockOnto;
						} else if (temp.GetComponent<HomingRocket>()!=null){
							temp.GetComponent<HomingRocket>().transformToMoveTowards = transformToLockOnto;
						}
					}
				}
				//++numBulletsFired;
				timeSinceLastShot = 0;
			}
			//if ()
			return numBulletsFired;
		}

		public override string ToString(){
			return name;
		}

		public void Update () {
			timeSinceLastShot += Time.deltaTime;
			deviationMultiplier -= deltaDeviationMultiplier * Time.deltaTime;
			deviationMultiplier = Mathf.Max (deviationMultiplier, minimumDeviationMultiplier);
			//if (magazines)
		}

		public FireMode Copy(){
			return (FireMode)this.MemberwiseClone();
		}

	}
}

