//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using AI;


namespace Weapons
{

	[Serializable]
	public enum WeaponState {
		Dropped, Raising, Ready, Reloading, TogglingAim, Holstered, Pulling_Grenade_Back, Throwing_Grenade, Lowered, Lowering
	}

	[Serializable]
	public class Weapon : MonoBehaviour
	{
		public WeaponName weaponName;
		//public AnimatableObject owner;
		public bool reloadable = true;
		//public float timeSinceLastShot;
		//public float reloadTime;
		//public float fireRate;

		int magNum = 0; //Which mag is currently being used.
		public WeaponState stateOfWeapon = WeaponState.Raising;
		public WeaponState previousWeaponState = WeaponState.Raising;
		//public WeaponState previousWeaponState = WeaponState.Raising;
		public FireMode[] fireModes;
		public int currentFireMode = 0;
		//public DictionaryOfFireModeAndGameObject projectileDictionary; //used to fire a different projectile based on the fire mode.
		public Transform barrelEnd, barrelStart;
		public GameObject prefabToSpawnOnDrop;
		//WeaponState weaponState = WeaponState.Dropped;
		public bool discardOnFire = false;
		public List<int> magazines = new List<int>{30,30}; //list of magazines with number of bullets in them.
		public int currentMag = 0;
		public int maxNumMags;
		public bool canBePickedUp = true;
		public int magSize = 30;
		public bool unlimitedAmmo = false;
		public float reloadTime = 1f;
        //public GameObject muzzleFlash;

        //public GameObject 

        public Weapon (/*AnimatableObject owner,*/ ref Transform barrelEnd, ref Transform barrelStart)
		{
			//this.owner = owner;
			this.barrelEnd = barrelEnd;
			this.barrelStart = barrelStart;
			//barrelEnd = GameObject.fin
		}

		public Weapon(){

		}

		public bool fire(Transform barrelEnd, Transform barrelStart, FactionName factionThatFiredShot, bool isAiming = false){
			//print (fireModes.Length);
			if (magazines.Count != 0) {
				currentMag = currentMag % magazines.Count;
			} else {
				currentMag = 0;
			}
			if (stateOfWeapon == WeaponState.Ready && magazines.Count>0) {
				magazines[currentMag]-=fireModes [currentFireMode].fire (barrelEnd.position, barrelStart.position, magazines[currentMag], factionThatFiredShot,isAiming);
				if (!discardOnFire && magazines[currentMag]<=0){
					magazines.RemoveAt(currentMag);
					if (magazines.Count>0){
						currentMag = currentMag%magazines.Count;
					}
					return true;
				}
			} else {
				//print ()
			}



			return false;
		}

		public bool fire(Vector3 barrelEnd, Vector3 barrelStart, FactionName factionThatFiredShot, bool isAiming = false){
			//print (fireModes.Length);
			if (magazines.Count != 0) {
				currentMag = currentMag % magazines.Count;
			} else {
				currentMag = 0;
			}
			if (stateOfWeapon == WeaponState.Ready && magazines.Count>0) {
				//Debug.Log("Firing weapon!");
				magazines[currentMag]-=fireModes [currentFireMode].fire (barrelEnd, barrelStart, magazines[currentMag], factionThatFiredShot,isAiming);
                // GameObject parentEnemy = FindParentWithTag(gameObject, "Character"); //soldiers direction
    //            Quaternion tempQ = Quaternion.LookRotation(barrelEnd - barrelStart);
				//GameObject go = (GameObject) Instantiate(muzzleFlash, this.barrelEnd.position, Quaternion.Euler(-90, (tempQ*Vector3.up).y, 
    //                0)); //parent = smoke
                
				//muzzleFlash.transform.position = this.barrelEnd.position;
    //            if (weaponName == WeaponName.M60 || weaponName == WeaponName.EnergyRifle)
    //            {

    //                go.transform.rotation = Quaternion.Euler(new Vector3(-90,90, 0) + tempQ.eulerAngles);
    //            }
    //            else
    //            {
    //                go.transform.GetChild(0).rotation = tempQ; //child at index 0 = stretched billboard
    //            }
 
    //            //go.transform.GetChild(0).rotation = transform.rotation;
    //            Destroy(go, 2.5f);

                if (!discardOnFire && magazines[currentMag]<=0){


					return true;
				}
			} else {
				//print ()
			}
			
			
			
			return false;
		}

		public string toggleFireMode(){
			//change state
			currentFireMode = (currentFireMode + 1) % fireModes.Length;
			return fireModes[currentFireMode].ToString();
		}

		void Update () {
			for (int i = 0; i< fireModes.Length; i++) {
				fireModes[i].Update();
			}

		}

		public Weapon Copy(){
			Weapon copy = (Weapon)this.MemberwiseClone ();
			for (int i = 0; i<copy.fireModes.Length; i++) {
				copy.fireModes[i] = this.fireModes[i].Copy();
			}
			//copy.magazines.Clear ();
			//this = copy;
			return copy;
		}

		//position is global
		public void dropWeapon(Vector3 position){
			GameObject temp = (GameObject)GameObject.Instantiate (prefabToSpawnOnDrop, position, Quaternion.identity);
			temp.GetComponent<Weapon>().stateOfWeapon = WeaponState.Dropped;
			temp.GetComponent<Weapon>().MakeIntoCopyOfWeapon(this);
			temp.transform.position = new Vector3 (temp.transform.position.x, temp.transform.position.y - 2, temp.transform.position.z);
			temp.transform.rotation = Quaternion.Euler (UnityEngine.Random.Range (0, 30), UnityEngine.Random.Range (0, 30), UnityEngine.Random.Range (0, 30));
		}

		public void MakeIntoCopyOfWeapon(Weapon weaponToCopy){
			this.weaponName = weaponToCopy.weaponName;
			//this.owner = weaponToCopy.owner;
			//this.float timeSinceLastShot;
			//this.reloadTime = weaponToCopy.reloadTime;
			//this.fireRate = weaponToCopy.fireRate;
			//this.magazines = weaponToCopy.magazines; //list of magazines with number of bullets in them.
			this.magNum = weaponToCopy.magNum; //Which mag is currently being used.
			this.stateOfWeapon = weaponToCopy.stateOfWeapon;
			this.fireModes = new FireMode[weaponToCopy.fireModes.Length];
			for (int i = 0; i< fireModes.Length; i++) {
				fireModes[i] = weaponToCopy.fireModes[i].Copy();

			}
			for (int j = 0; j<weaponToCopy.magazines.Count; j++){
				magazines.Add(weaponToCopy.magazines[j]);
			}
			this.currentFireMode = weaponToCopy.currentFireMode;
			//this.DictionaryOfFireModeAndGameObject projectileDictionary; //used to fire a different projectile based on the fire mode.
			this.barrelEnd = weaponToCopy.barrelEnd;
			this.barrelStart = weaponToCopy.barrelStart;
			this.prefabToSpawnOnDrop = weaponToCopy.prefabToSpawnOnDrop;
			this.discardOnFire = weaponToCopy.discardOnFire;
			this.reloadable = weaponToCopy.reloadable;
		}
	
//		public AnimatableObject Owner {
//			get {
//				return owner;
//			}

//			set {
//				owner = value;
//			}
//		}

		public FireMode getCurrentFireMode(){
			return fireModes [currentFireMode];
		}

		public WeaponState StateOfWeapon {
			get {
				return stateOfWeapon;
			}
			set {
				previousWeaponState = stateOfWeapon;
				stateOfWeapon = value;
			}
		}

		public WeaponState PreviousWeaponState {
			get {
				return previousWeaponState;
			}
		}

		public bool willFire(bool fireButtonHeldDown, bool fireButtonPressed){
			return ((fireButtonHeldDown && fireModes [currentFireMode].willFireIfButtonHeldDown) || (fireButtonPressed && fireModes [currentFireMode].willFireIfButtonTapped));
		}

		public void InsertNewMag(){

            
            if (magazines.Count > 0) {
				magazines.RemoveAt (currentMag);
				if (magazines.Count > 0) {
					currentMag = (currentMag + 1) % magazines.Count;
				}
			} else if (unlimitedAmmo) {
				magazines.Add(magSize);
				currentMag = 0;
				//if (magazines.Count > 0) {
				//	currentMag = (currentMag + 1) % magazines.Count;
				//}
			}

		}

        public static GameObject FindParentWithTag(GameObject childObject, string tag)
        {
            Transform t = childObject.transform;
            while (t.parent != null)
            {
                if (t.parent.tag.Substring(0, 9) == tag) //Character
                {
                    return t.parent.gameObject;
                }

                t = t.parent.transform;
            }
            return null; // Could not find a parent with given tag.
        }
    }


}

