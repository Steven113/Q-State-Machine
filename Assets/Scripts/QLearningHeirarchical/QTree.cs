//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using UnityEditor;
using UnityEngine;

namespace AssemblyCSharp
{
	[Serializable]
	public class QTree : IDeserializationCallback, EditorDisplay
	{
		public List<QNode> treeNodes = new List<QNode> ();
		public List<string> currentState = new List<string> ();
		public List<string> previousState = new List<string> ();
		float learningRate = 0.1f;
		float discountFactor = 0.3f;
		int stateLength = 1; //the length that a state list should be. As the heirarchy is universal, any path to any leaf state should have the same length

		public QTree (List<List<string>> heirarchy, List<QLink> rewardLinks, List<bool> autoLinksForThisHeirarchy, float learningRate, float discountFactor)
		{
			this.learningRate = learningRate;
			this.discountFactor = discountFactor;
			treeNodes.Capacity = 1;

			int numNodesToAdd = 1;

			StateLength = heirarchy.Count;

			List<List<QNode>> tempTree = new List<List<QNode>> (); //we need to divide into several lists, where nodes from list i are all children of nodes in list i-1. This makes assigning children easier
			QNode.currentID = 0;
			int numToAdd = 1;
			for (int i = 0; i<heirarchy.Count; ++i) {
				//List<QNode> layer = ;
				tempTree.Add(new List<QNode>());
				if (i==0){
					//tempTree[0].Add(new QNode(heirarchy[i],learningRate, discountFactor));
					tempTree[0].Add (new QNode (heirarchy [i], learningRate, discountFactor,(i!=(heirarchy.Count-1)),(i==(heirarchy.Count-1)),autoLinksForThisHeirarchy[i] || i == heirarchy.Count-1));
				} else {
					numToAdd*=heirarchy[i-1].Count;
					for (int j = 0; j<(numToAdd); ++j){
						//for (int k = 0; k<heirarchy[i].Count; ++k){
							tempTree[i].Add (new QNode (heirarchy [i], learningRate, discountFactor,(i!=(heirarchy.Count-1)),(i==(heirarchy.Count-1)),autoLinksForThisHeirarchy[i] || i == heirarchy.Count-1));
						//}
					}
				}


				//if (i ==0){
				//	treeNodes.Add(new QNode(heirarchy[i],learningRate, discountFactor));
				//treeNodes.Capacity = heirarchy[i].Count;
				//startIndex = 0;

				//} else
				//if (/*i<heirarchy.Count-1 &&*/ i>0){
				//startIndex = treeNodes.Count;
				//if (i>0){
				//	treeNodes.Capacity *= heirarchy [i].Count;
				//	numNodesToAdd *= heirarchy [i].Count;
				//}
				//for (int j = startIndex; j<endIndex; ++j){
				//for (int k = 0; k<numNodesToAdd; ++k) {
				//	treeNodes.Add (new QNode (heirarchy [i], learningRate, discountFactor,(i!=(heirarchy.Count-1)),(i==(heirarchy.Count-1)),autoLinksForThisHeirarchy[i] || i == heirarchy.Count-1));

				//}
				//}//
				//numNodesToAdd *= heirarchy [i].Count;
			}

			for (int i = 0; i<tempTree.Count; ++i){
				for (int j = 0; j<tempTree[i].Count; ++j){
					treeNodes.Add(tempTree[i][j]); //add into tree list
//					if (i>0){
//						int index = i==1?0:(j/(tempTree[i-1].Count));
//						Debug.Assert(tempTree[i-1][index].loadChildIndex(tempTree[i][j].ID));
//					}

				}
				if (i<(tempTree.Count-1)){
					int interval = tempTree[i+1].Count/tempTree[i].Count;
					for (int j = 0; j<tempTree[i].Count; ++j){
						for (int k = j*interval; k<(j+1)*interval; ++k){
							Debug.Assert(tempTree[i][j].loadChildIndex(tempTree[i+1][k].ID));
						}
					}
				}
			}

			//int startBound = 0;
			//int midBound = 1;
			//int endBound = 1;
//			for (int i = 0; i<heirarchy.Count-1; ++i) {
//				//endBound*=heirarchy[i].Count;
//				for (int j = 0; j<heirarchy[i].Count; ++j){
//					for (int k = 0; k<heirarchy[i+1].Count; ++k){
//						for (int m = 0; m<treeNodes.Count; ++m){
//							for (int n = m+1; n<treeNodes.Count; ++n){
//								//if (treeNodes[m].)
//								if (treeNodes[m].stateStringToIDArr.Contains(heirarchy[i][j]) && treeNodes[m].stateStringToIDArr.Contains(heirarchy[i+1][k])){
//									treeNodes[m].loadChildIndex(n);
//								}
//							}
//						}
//					}
//				}
//
//
//			}

			for (int m = 0; m<treeNodes.Count; ++m) {
				if (treeNodes[m].hasChildren){
					treeNodes[m].VerifyChildrenAssignment();
				}
			}
				
			//endIndex = treeNodes.Count;
		}

		public void SetParents(){
			for (int i = 0; i<treeNodes.Count; ++i) {
				treeNodes [i].parent = this;
			}
		}

		void IDeserializationCallback.OnDeserialization (System.Object sender)
		{
			SetParents ();
		}

		public void ToEditorView (){
			EditorGUILayout.LabelField ("Current State");
			EditorGUI.indentLevel+=3;
			for (int i = 0; i<currentState.Count; ++i) {
				currentState[i] = EditorGUILayout.TextField(currentState[i]);
			}
			EditorGUI.indentLevel-=3;

			EditorGUILayout.LabelField ("Previous State");
			EditorGUI.indentLevel+=3;
			for (int i = 0; i<previousState.Count; ++i) {
				previousState[i] = EditorGUILayout.TextField(previousState[i]);
			}
			EditorGUI.indentLevel-=3;
			treeNodes [0].ToEditorView ();
		}

		public int StateLength {
			get {
				return stateLength;
			}
			set {
				stateLength = value;
				while (currentState.Count<stateLength){
					currentState.Add("default");
				}

				while (previousState.Count<stateLength){
					previousState.Add("default");
				}
			}
		}
	}
}

