//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Collections;
using UnityEngine.AI;
using Weapons;
using Gameplay;
using AI;

namespace AssemblyCSharp
{
	[RequireComponent (typeof(ControlHealth))]
	public class QSoldier : QSensor
	{



		public static int currentAgent = 0;

		//public Transform transformToDoLosChecksFrom;

		public bool useCheatConditions = false;



		public float previousTargetHealth = 0;

		[Header("Referenced Components")]
		public UnityEngine.AI.NavMeshAgent agent;
		public QAgent qAgent;

		public Weapon weapon;
		public ControlHealth healthController;

		[Header("Reward + Pathfinding")]
		public List<string> currentActionSet = new List<string> ();
		public Collection<Vector3> path = new Collection<Vector3> ();

		public float reward = 0;
		public bool autoSetReward = true;
		public float healthRewardMultiplier = 1f;
		public float hasPathReward = 1f;

		public Vector3 previousPos;
		public float posRewardThreshold = 1f;

		[Header("Food")]
		public int smallFoodCount = 2;
		//for small heals
		public int bigFoundCount = 1;
		//for big heals

		public float actionUpdateInterval = 0.5f;
		public float timeSinceLastActionUpdate = 1000f;

		[Header("AI Update Rate")]
		//Data for controlling update rate
		public float AIUpdateInterval = 0.1f;
		public float timeSinceLastUpdate = 1000f;
		public float intervalForUpdatingCurrentTarget = 0.07f;
		public float timeSinceLastUpdatingCurrentTarget = 1000f;
		public float intervalForUpdatingPath = 0.2f;
		public float timeSinceLastUpdatingCurrentPath = 1000f;
		public float intervalForUpdatingAssaultPathOffset = 5f;
		public float timeSinceLastUpdatingAssaultPathOffset = 1000f;
		public float intervalForUpdatingSuppressionPathOffset = 5f;
		public float timeSinceLastUpdatingSuppressionPathOffset = 1000f;
		public float intervalForUpdatingFlankingPathOffset = 5f;
		public float timeSinceLastUpdatingFlankingPathOffset = 1000f;

		[Header("LOS Check Variables")]
		//Data related to LOS checks
		//public SoldierEntity thisEntity;
		public float verticalLOSDistance = 100;
		public float horizontalLOSDistance = 10000;
		public float maxRangeForEngagement = 300;
		public float verticalFOVAngle = 30f;
		public float horizontalFOVAngle = 60f;
		public float peripheralVisionDistance = 2f;
		public Transform transformToDoLOSChecksFrom;
		public float angleToDetermineWhetherTwoSoldiersAreLinedUp = 10f;
		Quaternion angleOfLookVector = Quaternion.identity;
		public RaycastHit hit;
		public RaycastHit hit2;
		public Ray LOSRay;
		public float amountOfTimeBeforePlayerIsConsideredLost = 5f;
		public float maxDistanceForUsingHighAccuracyLOSChecks = 100f;


		[Header("Combat Behaviour")]
		//Data related to combat behaviour
		[SerializeField]SoldierEntity currentTarget = null;
		public LOSResult currentTargetIsVisible = LOSResult.Invisible;
		public float amountOfTimeCurrentTargetHasBeenInLOS;
		public bool enableDebugPrint = false;
		public bool enableDebugVisualizations = false;
		public List<SoldierEntity> currentlyVisibleEnemies = new List<SoldierEntity> ();
		//public FactionName thisEntity.faction = FactionName.QHeirarchyArmy;
		//public bool currentTargetHasChanged;
		public AISoldierState soldierState;
		public Vector3 previousEnemyPos;
		public LayerMask LOSCheckLayers;
		public float horizontalRotationRate = 90f;
		public float verticalRotationRate = 30f;
		public Vector3 lookDirection;
		//what direction is the agent looking?

		public float timeOfLastSuppression = 0;
		public float timeBeforeForgettingSuppression = 10f;
		public float weightingWhenMovingBackOntoPath = 0.1f;
		public float speed = 1f;
		public float sprintSpeed = 1.5f;
		bool friendlySoldierInLineOfFire;
		SoldierEntity thisEntity;
		[SerializeField]float maxAngleOffsetForFiringShotsNotLinedUpWithBarrel = 10f;
		[SerializeField]float amountOfTimePlayerMustBeVisibleBeforeShooting = 0.1f;

		[Header("Misc")]
		public GameObject smallHealEffect;
		public GameObject bigHealEffect;

		public Collider suppressionSphere;



		[SerializeField]int numActionsBusyWith = 0;

		//[Header("Referenced Components")]
		public BoxCollider mapBounds;

		NavMeshHit nav_hit;

		//float [] expectedScores = new float[]{0,0};

		/// <summary>
		/// Reward agent with given reward value
		/// </summary>
		/// <param name="reward">Reward.</param>
		public override void Reward (float reward)
		{
			qAgent.RewardAgent (reward);
		}

		bool exploring = false;

		//public Dictionary<FactionName,int> scoreMap = new Dictionary<FactionName, int>();

		//inilization and update methods
		public void Awake ()
		{
			lookDirection = gameObject.transform.forward;
			agent = gameObject.GetComponent<UnityEngine.AI.NavMeshAgent> (); //get navmesh agent
			agent.updateRotation = false; //disable automatic rotation of agent so that it won't automatically look in the direction it is moving

			if (suppressionSphere != null) {
				GameData.SuppressionSphereDictionary.Add (suppressionSphere, healthController);
			}
			currentActionSet = new List<string> ();
			//GameData.addEntity(thisEntity)

		}

		public void Start ()
		{
			thisEntity = GetComponent<CreateSoldierEntity> ().entity;
			healthController.AddOnDamageEvent (this.OnDamage);
			previousPos = gameObject.transform.position;
		}

		public virtual void Update ()
		{
			//if (healthController.health > 0) {
			UpdateMovement ();
			UpdateOrientation ();
			UpdateFriendlyFireFlag ();
			timeSinceLastUpdatingCurrentPath += Time.deltaTime;
			timeSinceLastUpdate += Time.deltaTime;
			timeSinceLastActionUpdate += Time.deltaTime;

//			if (GameData.scores [0] != expectedScores [0] || GameData.scores [1] != expectedScores [1]) {
//				CurrentTarget = null;
//				expectedScores [0] = GameData.scores [0];
//				expectedScores [1] = GameData.scores [1];
//			}

			/*
			 * This code runs unless we have set up the system to give reward based on the reward the player gives
			 */
			if (autoSetReward) {
				reward += healthRewardMultiplier*(healthController.health / healthController.maxhealth) * (Time.deltaTime);
				if (Vector3.SqrMagnitude (gameObject.transform.position - previousPos) > posRewardThreshold * posRewardThreshold) {
					previousPos = gameObject.transform.position;
					reward += (posRewardThreshold/agent.speed) * hasPathReward;
				}
				FactionName[] activeFactions = GameData.ActiveFactions ();
				for (int i = 0; i < activeFactions.Length; ++i) {
					if (activeFactions [i] == thisEntity.faction) {
						continue;
					}
					//if (scoreDiff<0){
					reward += ((GameData.scores[thisEntity.faction] - GameData.scores[activeFactions [i] ])*Time.deltaTime);
				}
				//}

				if (autoSetReward && currentTargetIsVisible == LOSResult.Visible && weapon.stateOfWeapon == WeaponState.Reloading) {
					reward -= (Time.deltaTime * 10);
				}

				if (currentTarget != null && currentTarget.mainLOSCollider != null) {
//					if (previousTargetHealth < currentTarget.controlHealth.health) {
//						qAgent.RewardAgent (10);
//						previousTargetHealth = currentTarget.controlHealth.maxhealth;
//					}
//					if (currentTarget.controlHealth.health < previousTargetHealth) {
//						reward += (previousTargetHealth - currentTarget.controlHealth.health);
//						previousTargetHealth = currentTarget.controlHealth.health;
//
//					}
				}
			}

			/*
			 * This code makes the agent more efficient by making it not update on every frame
			 */
			if (timeSinceLastUpdate > AIUpdateInterval) {
				timeSinceLastUpdate %= AIUpdateInterval;
				UpdateLOSInfo ();

			}

			/*
			 * Get a new action, if an appropriate interval has passed after getting the last action
			 */
			if (timeSinceLastActionUpdate > actionUpdateInterval) {

				//if (!(weapon.stateOfWeapon == WeaponState.Reloading)) {
					timeSinceLastActionUpdate %= actionUpdateInterval; // this statement gets moved here so that only if the next action is requested do we restart the timer before requesting an action
					if (autoSetReward) {
						qAgent.RewardAgent (reward); //we call the q agent reward directly, as we don't want to pointlessly add another function call to the stack by calling the reward method of this class
						reward = 0;
					}

					currentActionSet = qAgent.GetAction (getState (), getStateValues ());
					
				/*
				 * We immediately apply the action of turning 180 degrees
				 */
				if (currentActionSet.Contains ("Turn180")){
					Vector3 c_dest = agent.destination;
					gameObject.transform.Rotate (new Vector3 (0, 180, 0));

					/*
					 * we need to put the agent back on the navmesh in case rotating
					 * it put the agent off the navmesh. This can happen if the navmesh
					 * modek has a different centre to the agent
					 */
					agent.SetDestination (c_dest);
				}
				//}
			}
			//thisEntity.faction
			//if (shuffleIndex % 2 == 0) {
			if (currentActionSet.Contains ("Shoot") && weapon.stateOfWeapon == WeaponState.Ready && (!useCheatConditions || (weapon.magazines.Count > 0 && weapon.magazines [weapon.currentMag] > 0))) {
				/*
				 *  Punish agent if it tries to shoot while having no ammo. This is meant to encourage it to reload
				 */
				if (autoSetReward && (weapon.magazines.Count == 0 || weapon.magazines [weapon.currentMag] == 0)) {
					reward -= Time.deltaTime;
				} else if ((currentTarget != null && currentTarget.mainLOSCollider != null)) {
					reward += Time.deltaTime;
				}

				/*
				 * If a enemy is in sight we point bullets towards the enemy even
				 * if the barrel doesn't face the enemy, assuming that the angle
				 * that the bullet is adjusted by
				 * (the angle between the barrel and the line from this agent to the enemy)
				 * isn't too large.
				 * If the angle is too large or if there is no opponent, the bullet follows the 
				 * direction of the gun barrel
				 */
				if (CurrentTarget == null || Vector3.Angle(gameObject.transform.forward,(currentTarget.mainLOSCollider.gameObject.transform.position-weapon.barrelStart.position))>maxAngleOffsetForFiringShotsNotLinedUpWithBarrel) {
					weapon.fire (weapon.barrelEnd.position, weapon.barrelStart.position, thisEntity.faction, false);
				} else {
					weapon.fire (((currentTarget.mainLOSCollider.gameObject.transform.position-weapon.barrelStart.position).normalized*(weapon.barrelEnd.position-weapon.barrelStart.position).magnitude) + weapon.barrelStart.position, weapon.barrelStart.position, thisEntity.faction, false);
				}


			} else 
				/*
				 * If out of ammo, reload
				 */
			if (currentActionSet.Contains ("Reload") && weapon.stateOfWeapon != WeaponState.Reloading && (!useCheatConditions || (weapon.magazines.Count == 0 || weapon.magazines [weapon.currentMag] < weapon.magSize * 0.5f))) {
				StartCoroutine (Reload ());
			}


//			} else {
//				if (currentActionSet.Contains ("SHOOT") && weapon.stateOfWeapon == WeaponState.Ready) {
//					weapon.fire(weapon.barrelEnd.position,weapon.barrelStart.position,thisEntity.faction,false);
//				} else if (currentActionSet.Contains ("RELOAD") && weapon.stateOfWeapon!=WeaponState.Reloading) {
//					StartCoroutine(Reload());
//				}
//			}

			/* apply action for healing */
			if (currentActionSet.Contains ("BigHeal")) {
				heal (false);
			} else if (currentActionSet.Contains ("Heal")) {
				heal (true);
			}




		}

		/// <summary>
		/// Get continuous state variables of agent e.g. health
		/// </summary>
		/// <returns>The state values.</returns>
		public override List<float> getStateValues ()
		{
			List<float> data = new List<float> ();
			data.Add (healthController.health / healthController.maxhealth); //we normalize the health
			data.Add ((weapon.magazines.Count>0)?(weapon.magazines [weapon.currentMag] / weapon.magSize):0);
			data.Add (currentlyVisibleEnemies.Count);
			data.Add (healthController.suppressionLevel);
			data.Add (smallFoodCount);
			data.Add (bigFoundCount);
			data.Add ((currentTargetIsVisible == LOSResult.Invisible)?0:1);
			return data;
		}

		/// <summary>
		/// Does nothing since we have no enumerable state variables
		/// </summary>
		/// <returns>The state.</returns>
		public override List<string> getState ()
		{
			List<string> result = new List<string> ();
			
//			if (weapon.weaponName == WeaponName.Rifle) {
//				result.Add ("RIFLE");
//			} else if (weapon.weaponName == WeaponName.Rocket_Launcher) {
//				result.Add ("ROCKET_LAUNCHER");
//			}
//
//			if (currentTargetIsVisible == LOSResult.Visible) {
//				result.Add ("ENEMY_VISIBLE");
//			}
//
//			if (weapon.stateOfWeapon == WeaponState.Reloading) {
//				result.Add ("RELOADING");
//			}
//
//			throw new NotImplementedException ();

			return result;
		}

		/// <summary>
		/// This messy piece of code updates what enemies are in line of sight and 
		/// what enemy is the current target. It is so messy since it is compact
		/// for efficiency.
		/// </summary>
		public virtual void UpdateLOSInfo ()
		{
			currentlyVisibleEnemies.Clear ();
//			if (fireTeamController != null) {
//				fireTeamController.removeVisibleEntities (currentlyVisibleEnemies);
//			}
			for (int i = 0; i < GameData.Factions.Count; i++) {
				if (GameData.Factions [i].FactionName != thisEntity.faction) {
					for (int j = 0; j < GameData.Factions [i].Soldiers.Count; j++) {
						LOSResult soldierIsVisible = LOSResult.Invisible;
						if (currentTarget == null || currentTarget != GameData.Factions [i].Soldiers [j]) {
							if (GameData.Factions [i].Soldiers [j] != null && GameData.Factions [i].Soldiers [j].mainLOSCollider != null &&
							    !GameData.Factions [i].Soldiers [j].isNeutral) {
								soldierIsVisible = isInLineOfSight (GameData.Factions [i].Soldiers [j]);
								if (soldierIsVisible == LOSResult.Visible) {
									if (!currentlyVisibleEnemies.Contains (GameData.Factions [i].Soldiers [j])) {
										currentlyVisibleEnemies.Add (GameData.Factions [i].Soldiers [j]);
									}
									if (currentTarget == null || currentTarget.mainLOSCollider == null ||
									    (Vector3.Distance (currentTarget.mainLOSCollider.transform.position, transformToDoLOSChecksFrom.position) >
									    Vector3.Distance (GameData.Factions [i].Soldiers [j].mainLOSCollider.transform.position, transformToDoLOSChecksFrom.position))) {
										
										if (currentTarget != null) {
											if (!currentlyVisibleEnemies.Contains (currentTarget)) {
												currentlyVisibleEnemies.Add (currentTarget);
											}
										}
										
										if (enableDebugPrint)
											Debug.Log ("Target spotted!");
										CurrentTarget = GameData.Factions [i].Soldiers [j];
										
										
										
									} else {
//										if (currentTarget != null) {
//											if (!currentlyVisibleEnemies.Contains (currentTarget)) {
//												currentlyVisibleEnemies.Add (currentTarget);
//											}
//										}
									}
									//  if (fireTeamController!=null)
									//  {
									// fireTeamController.ReportThreat(GameData.Factions[i].Soldiers[j]);
									// }
								}
							}
						}
					}
				}
			}
			
//			if (fireTeamController != null) {
//				fireTeamController.loadVisibleEntities (currentlyVisibleEnemies);
//			}
		}

		/// <summary>
		/// Checks whether the given agent is in line of sight.
		/// Again, the code is compact and messy for efficiency purposes
		/// </summary>
		/// <returns>The in line of sight.</returns>
		/// <param name="entity">Entity.</param>
		public virtual LOSResult isInLineOfSight (SoldierEntity entity)
		{

			Color randCol = new Color (UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);

			if (Vector3.Distance (entity.centreOfMass.position, transformToDoLOSChecksFrom.position) > horizontalLOSDistance || Mathf.Abs (Vector3.Angle (weapon.barrelEnd.position - weapon.barrelStart.position, entity.centreOfMass.position - transformToDoLOSChecksFrom.position)) > horizontalFOVAngle) {
				if (enableDebugPrint)
					Debug.Log ("Not withing FOV angle!");
				if (Vector3.Distance (entity.centreOfMass.position, transformToDoLOSChecksFrom.position) < peripheralVisionDistance) {
					return LOSResult.PeripheralVisionTriggered;
				} else {
					return LOSResult.Invisible;
				}
			} else {
				LOSRay.origin = transformToDoLOSChecksFrom.position;
				LOSRay.direction = entity.centreOfMass.position - transformToDoLOSChecksFrom.position;
				if (enableDebugVisualizations)
					Debug.DrawRay (LOSRay.origin, LOSRay.direction, randCol, 0.1f);
				
				if ((Physics.Raycast (LOSRay, out hit, Vector3.Distance (entity.centreOfMass.position, transformToDoLOSChecksFrom.position) + 10, LOSCheckLayers))) {
					if (hit.collider == entity.mainLOSCollider) {
						//if (enableDebugVisualizations) if (enableDebugVisualizations) Debug.DrawRay(transformToDoLOSChecksFrom.position,entity.centreOfMass.position - transformToDoLOSChecksFrom.position,Color.red,0.1f);
						if (Vector3.Distance (entity.centreOfMass.position, transformToDoLOSChecksFrom.position) < maxDistanceForUsingHighAccuracyLOSChecks && entity.LOSCheckColliders.Length > 0 && entity.LOSCheckTransforms.Length > 0) {
							for (int i = 0; i < entity.LOSCheckColliders.Length; i++) {
								LOSRay.direction = entity.LOSCheckTransforms [i].position - transformToDoLOSChecksFrom.position;
								//if (enableDebugVisualizations) if (enableDebugVisualizations) Debug.DrawRay(transformToDoLOSChecksFrom.position, entity.LOSCheckTransforms[i].position - transformToDoLOSChecksFrom.position,Color.red,0.1f);
								if ((Physics.Raycast (LOSRay, out hit, Vector3.Distance (entity.centreOfMass.position, transformToDoLOSChecksFrom.position) + 10, LOSCheckLayers))) {
									if (hit.collider.Equals (entity.LOSCheckColliders [i])) {
										//currentlyVisibleEnemies.Add(entity);
										return LOSResult.Visible;
									}
								}
							}
						} else {
							//currentlyVisibleEnemies.Add(entity);
							if (enableDebugPrint)
								Debug.Log ("High accuracy visibility checks skipped!");
							return LOSResult.Visible;
						}
					} else {
						for (int i = 0; i < entity.LOSCheckColliders.Length; i++) {
							if (hit.collider.gameObject.Equals (entity.LOSCheckColliders [i].gameObject)) {
								return LOSResult.Visible;
							}
						}
						
						
						if (enableDebugPrint)
							Debug.Log ("MainLOSColliderNotVisible! " + entity.mainLOSCollider.gameObject.transform.root.gameObject.name + ". It hit " + hit.collider.gameObject.transform.root.gameObject.name + " " + entity.LOSCheckColliders.Length);
						//if (enableDebugVisualizations) if (enableDebugVisualizations) Debug.DrawRay(transformToDoLOSChecksFrom.position,hit.point - transformToDoLOSChecksFrom.position,Color.green,0.1f);
						return LOSResult.Invisible;
					}
				}
				if (enableDebugPrint)
					Debug.Log ("Rays didn't hit anything!");
				return LOSResult.Invisible;
				//}
			}
		}

		/// <summary>
		/// Update direction agent is facing
		/// </summary>
		public virtual void UpdateOrientation ()
		{
			Vector3 temp = Vector3.zero;
			/*
			 * If there is a current target which is visible, look towards that target
			 */
			if (currentTarget != null && currentTarget.mainLOSCollider != null && amountOfTimeCurrentTargetHasBeenInLOS > 0 /*&& (currentTarget.centreOfMass.position-transformToDoLOSChecksFrom.position).magnitude<lookDirection.magnitude*/) {
				temp = currentTarget.mainLOSCollider.transform.position;
				temp.y = gameObject.transform.position.y;
				Quaternion tempQ = Quaternion.LookRotation (temp - gameObject.transform.position);
				gameObject.transform.rotation = Quaternion.RotateTowards (gameObject.transform.rotation, tempQ, Time.deltaTime * horizontalRotationRate);
			} else
				/*
				 * If there is no current target or the current target is not visible, look towards a arbitrary currently visible enemy
				 */
			if (currentlyVisibleEnemies.Count > 0 && currentlyVisibleEnemies [0].mainLOSCollider != null && (currentlyVisibleEnemies [0].centreOfMass.position - transformToDoLOSChecksFrom.position).magnitude < lookDirection.magnitude) {
				temp = currentlyVisibleEnemies [0].mainLOSCollider.transform.position;
				temp.y = gameObject.transform.position.y;
				Quaternion tempQ = Quaternion.LookRotation (temp - gameObject.transform.position);
				gameObject.transform.rotation = Quaternion.RotateTowards (gameObject.transform.rotation, tempQ, Time.deltaTime * horizontalRotationRate);
			} 
			/*
			 * if no currently visible enemies, look towards "lookForward" direction.
			 * lookfoward will either face the direction the agent is moving 
			 * or in the direction enemy fire is coming from
			 */
				else { /*if (agent.hasPath)*/
				if ((Time.time - timeOfLastSuppression) > timeBeforeForgettingSuppression) {
					if (agent.hasPath) {
						lookDirection = weightingWhenMovingBackOntoPath * Time.deltaTime * (
						    agent.steeringTarget - agent.transform.position).normalized + (1 - weightingWhenMovingBackOntoPath * Time.deltaTime) * lookDirection;
					} else {
						lookDirection = weightingWhenMovingBackOntoPath * Time.deltaTime * (gameObject.transform.forward) + (1 - weightingWhenMovingBackOntoPath * Time.deltaTime) * lookDirection;
					}
				}
				temp = agent.transform.position + ((lookDirection != Vector3.zero) ? lookDirection : gameObject.transform.forward);
				temp.y = gameObject.transform.position.y;
				Quaternion tempQ = Quaternion.LookRotation (temp - gameObject.transform.position);
				gameObject.transform.rotation = Quaternion.RotateTowards (gameObject.transform.rotation, tempQ, Time.deltaTime * horizontalRotationRate);
			}


		}

		/// <summary>
		/// This property updates the current target based on whether it actually changed.
		/// </summary>
		/// <value>The current target.</value>
		public SoldierEntity CurrentTarget {
			get {
				if (currentTarget != null && currentTarget.mainLOSCollider == null) {
					return null;
				}
				return currentTarget;
			}

			set {
				//rotationAmountWhenSearching *= -1;
				//pointToDoRandomizationFrom = UnityEngine.Random.Range (0, 1000);
			
				if (currentTarget != null && currentTarget.mainLOSCollider != null) {
					if (enableDebugPrint)
						Debug.Log ("Retrieving intel from " + thisEntity.faction.ToString () + " about target from " + currentTarget.faction.ToString ());
					Debug.Assert (GameData.getFaction (thisEntity.faction) != null);
					GameData.getFaction (thisEntity.faction).getSoldierIntel (currentTarget).numSoldiersAssignedToThisTarget -= 1;
				}
			
				//if (currentTarget!=value){
				//	waypoints.Clear();
				//}
			
				amountOfTimeCurrentTargetHasBeenInLOS = intervalForUpdatingCurrentTarget * 2;
			
				if (value != null && value != currentTarget && value.mainLOSCollider != null) {
//				if (fireTeamController!=null && !radioSilence && !currentlyVisibleEnemies.Contains(value) && Vector3.Distance(value.centreOfMass.position,gameObject.transform.position)<maxRangeForEngagement){
//					fireTeamController.PlayEventSound(RadioEventType.PlayerSpotted,soldierAudioSource);
//				}
					//currentTargetHasChanged = true;
					previousTargetHealth = value.controlHealth.health;
				}
			
				currentTarget = value;
			
				/*
				 * If the current target is changed, reset var
				 */
				if (currentTarget != null && currentTarget.mainLOSCollider != null) {
					if (enableDebugPrint)
						Debug.Log ("Setting target to " + currentTarget.mainLOSCollider.gameObject.name + " for " + gameObject.transform.position);
					soldierState = AISoldierState.EngagingTarget;
					GameData.getFaction (thisEntity.faction).getSoldierIntel (currentTarget).numSoldiersAssignedToThisTarget += 1;
					previousEnemyPos = currentTarget.centreOfMass.position;
				
				} else {
					soldierState = AISoldierState.Idle;
					amountOfTimeCurrentTargetHasBeenInLOS = -1000;
					currentTargetIsVisible = LOSResult.Invisible;
				
				}
			
			
			
			}
		}

		/// <summary>
		/// Updates movement based on movement action given to agent
		/// </summary>
		public void UpdateMovement ()
		{
			
			if (timeSinceLastUpdatingCurrentPath > intervalForUpdatingPath) {
				timeSinceLastUpdatingCurrentPath %= intervalForUpdatingPath;
				if (currentActionSet != null) {
					if (currentTarget == null || currentTarget.mainLOSCollider == null) {
						/*
						 * If exploring, find random point in world bounds and move to whatever point on the navmesh
						 * is nearest that point
						 */
						if (currentActionSet.Contains ("Explore") && (!exploring || (exploring && agent.remainingDistance == 0))) {
							exploring = true;
							//origin for search
							Vector3 scaledBounds = mapBounds.gameObject.transform.TransformPoint(mapBounds.size);
							Vector3 searchPoint = new Vector3 (mapBounds.gameObject.transform.position.x + (UnityEngine.Random.value - 0.5f )* 2 * scaledBounds.x, mapBounds.gameObject.transform.position.y + (UnityEngine.Random.value - 0.5f )* 2 * scaledBounds.y, mapBounds.gameObject.transform.position.z + (UnityEngine.Random.value - 0.5f )* 2 * scaledBounds.z);

							//Debug.DrawRay (searchPoint, Vector3.up*100, Color.red, 30f);

							NavMesh.SamplePosition (searchPoint, out nav_hit, float.PositiveInfinity, agent.areaMask);

							agent.SetDestination (nav_hit.position);

						} else
							/*
							 * If seeking cover, find nearest edge. The nearest edge will be near a wall usually,
							 * hence this hack normally works
							 */
						if (currentActionSet.Contains ("GoToCover")) {
							exploring = false;
							NavMesh.FindClosestEdge (agent.transform.position, out nav_hit, agent.areaMask);
							agent.SetDestination (nav_hit.position);
						}
					} else {
						/*
						 * If fleeing, estimate place in world bounds that is furtherest from enemy and move towards
						 * point on navmesh that is the closest to that fleeing point
						 */
						if (currentActionSet.Contains ("Flee")) {
							exploring = false;
							//if (currentTarget != null) {
							Vector3 searchPoint = new Vector3 (mapBounds.center.x + (UnityEngine.Random.value - 0.5f )* 2 * mapBounds.size.x, mapBounds.center.y + (UnityEngine.Random.value - 0.5f )* 2 * mapBounds.size.y, mapBounds.center.z + (UnityEngine.Random.value - 0.5f )* 2 * mapBounds.size.z);

								if (Vector3.Dot (searchPoint - agent.transform.position, currentTarget.mainLOSCollider.transform.position - agent.transform.position) > 0) {
									searchPoint = -searchPoint;
								}

								NavMesh.SamplePosition (searchPoint, out nav_hit, float.PositiveInfinity, agent.areaMask);

								agent.SetDestination (nav_hit.position);
						} else 
							/*
							 * If moving to enemy, try to move to the enemy, if there is one
							 */
							if (currentActionSet.Contains ("MoveTo") && currentTarget != null && currentTarget.centreOfMass != null) {
							exploring = false;
							agent.SetDestination (currentTarget.centreOfMass.position);
							//AIGrid.findPath (this, gameObject.transform.position, currentTarget.centreOfMass.position, out path, false, false);
						}
					}
				}

			}
//			else {
//				if (CurrentTarget.mainLOSCollider!=null){
//					//TO-DO
//				} else {
//					AIGrid.findExplorationPath(this,gameObject.transform.position,out path, 5);
//					//Debug.Log(path.Count);
//				}
//			}


		}

		/// <summary>
		/// Make weapon ready to fire one reload interval has elapsed
		/// </summary>
		public IEnumerator Reload ()
		{
//			if (autoSetReward) {
//				reward += (1f - ((weapon.magazines.Count > 0 ? weapon.magazines [weapon.currentMag] : 0) / weapon.magSize)); // we give reward based on how many bullets are in mag, to reward reloads where the mag is empty or near empty
//				reward -= 0.5f;
//			}
			++numActionsBusyWith;
			weapon.stateOfWeapon = WeaponState.Reloading;
			yield return new WaitForSeconds (weapon.reloadTime);
			--numActionsBusyWith;
			weapon.stateOfWeapon = WeaponState.Ready;
			weapon.InsertNewMag ();


			//animationObject.CrossFade(avatarAlias+"|"+weaponName.ToString()+" Idle");
		}

		[Obsolete]
		/// <summary>
		/// Makes agent fire at the current target if possible
		/// </summary>
		public virtual void AttackTarget ()
		{
			
			SoldierEntity temp = null;
			if (currentTarget != null && currentTarget.mainLOSCollider != null /*&& amountOfTimeCurrentTargetHasBeenInLOS >= fireDelayTime*/) {
				temp = currentTarget;
			} else if (currentlyVisibleEnemies.Count > 0) {
				temp = currentlyVisibleEnemies [0];
			}
			
			
			if (temp != null) {
				//code for aiming towards player goes here
				
				//code for firing
				
				//if (enableDebugVisualizations) if (enableDebugVisualizations) Debug.DrawRay(barrelStart.position,barrelEnd.position - barrelStart.position,Color.red,0.1f);
				if (enableDebugVisualizations)
				if (enableDebugVisualizations)
					Debug.DrawRay (weapon.barrelStart.position, temp.centreOfMass.position - weapon.barrelStart.position, Color.blue, 0.1f);
				if (enableDebugPrint)
					Debug.Log ("Vector3.Angle(weaponList[currentWeapon].barrelEnd.position - weaponList[currentWeapon].barrelStart.position,temp.centreOfMass.position - weaponList[currentWeapon].barrelStart.position) " + Vector3.Angle (weapon.barrelEnd.position - weapon.barrelStart.position, temp.centreOfMass.position - weapon.barrelStart.position));
				if (weapon.stateOfWeapon == WeaponState.Ready && !friendlySoldierInLineOfFire && Vector3.Distance (temp.centreOfMass.position, transformToDoLOSChecksFrom.position) < maxRangeForEngagement && maxAngleOffsetForFiringShotsNotLinedUpWithBarrel > Mathf.Abs (Vector3.Angle (weapon.barrelEnd.position - weapon.barrelStart.position, temp.centreOfMass.position - weapon.barrelStart.position)) && (currentTargetIsVisible == LOSResult.Visible || amountOfTimeCurrentTargetHasBeenInLOS < amountOfTimePlayerMustBeVisibleBeforeShooting)) {
					if (weapon.fire (weapon.barrelEnd, weapon.barrelStart, thisEntity.faction, false)) {
						//animationObject.CrossFade(avatarAlias+"|"+weaponName.ToString()+" Reload");
						//weapon.stateOfWeapon = WeaponState.Reloading;
					}// else {
					
					//}
				} else {
					if (enableDebugPrint)
						Debug.Log ("Target not in path of weapon!");
				}
			} else {
				if (enableDebugPrint)
					Debug.Log ("No target");
			}
		}

		/// <summary>
		/// Checks whether agent can shoot without hitting a friendly soldier
		/// </summary>
		protected virtual void UpdateFriendlyFireFlag ()
		{
			friendlySoldierInLineOfFire = false;
			SoldierEntity temp = null;
			if (currentTarget != null && currentTarget.mainLOSCollider != null /*&& amountOfTimeCurrentTargetHasBeenInLOS > weapon.fireDelayTime*/) {
				temp = currentTarget;
			} else if (currentlyVisibleEnemies.Count > 0) {
				temp = currentlyVisibleEnemies [0];
			}
			//			if (fireTeamController != null) {
			//				for (int i= 0; i<fireTeamController.fireTeamMembers.Count; i++) {
			//					LOSRay.direction = weapon.barrelEnd.position - weapon.barrelStart.position;
			//					LOSRay.origin = weapon.barrelStart.position;
			//					if (fireTeamController.fireTeamMembers [i] != this && fireTeamController.fireTeamMembers [i].thisEntity.mainLOSCollider.Raycast (LOSRay, out hit, float.PositiveInfinity) && Vector3.Distance (hit.point, weapon.barrelStart.position) < Vector3.Distance (temp.centreOfMass.position, weapon.barrelStart.position)) {
			//						if (enableDebugPrint) Debug.Log ("Friendly soldier in the way!");
			//						friendlySoldierInLineOfFire = true;
			//						break;
			//					}
			//				}
			//			}
			if (temp != null && temp.centreOfMass != null) {
				for (int i = 0; i < GameData.getFaction (thisEntity.faction).Soldiers.Count; ++i) {
					LOSRay.direction = weapon.barrelEnd.position - weapon.barrelStart.position;
					LOSRay.origin = weapon.barrelStart.position;
					if (GameData.getFaction (thisEntity.faction).Soldiers [i] != thisEntity
					    && GameData.getFaction (thisEntity.faction).Soldiers [i].mainLOSCollider.Raycast (LOSRay, out hit, float.PositiveInfinity) && Vector3.Distance (hit.point, weapon.barrelStart.position) < Vector3.Distance (temp.centreOfMass.position, weapon.barrelStart.position)) {
						if (enableDebugPrint)
							Debug.Log ("Friendly soldier in the way!");
						friendlySoldierInLineOfFire = true;
						break;
					}
				}
			}
			
		}

		/// <summary>
		/// Heals the soldier if the appropriate healing item is available
		/// </summary>
		/// <param name="useSmallHeal">If set to <c>true</c> use small heal.</param>
		public void heal (bool useSmallHeal)
		{
			float initialHealth = healthController.health;
			if (useSmallHeal && smallFoodCount > 0) {
				--smallFoodCount;
				healthController.heal (healthController.maxhealth * 0.25f);
				GameObject.Instantiate (smallHealEffect, gameObject.transform.position, Quaternion.identity);
			} else if (!useSmallHeal && bigFoundCount > 0) {
				--bigFoundCount;
				healthController.heal (healthController.maxhealth * 0.5f);
				GameObject.Instantiate (bigHealEffect, gameObject.transform.position, Quaternion.identity);
			}
			if (autoSetReward)
				reward += ((healthController.health - initialHealth) / healthController.maxhealth); //give reward based on change in health
		}

		/// <summary>
		/// Equivalent of destructor for Unity Engine. Cleans up agent data.
		/// </summary>
		public virtual void OnDestroy ()
		{
			
			healthController.RemoveOnDamageEvent (this.OnDamage);
			GameData.SuppressionSphereDictionary.Remove (suppressionSphere);
		}

		/// <summary>
		/// Respawn agent data
		/// </summary>
		public void Respawn ()
		{
			//qAgent.RewardAgent (-10);
			//reward = 0f;
			if (autoSetReward) {
				reward -= 10;
			}
			Vector3 spawnPoint = new Vector3 (1, 0, 1);
			//++GameData.scores [((int)(thisEntity.faction) + 1) % GameData.scores.Length];
			//Debug.Log (thisEntity.faction.ToString () + " " + (((int)(thisEntity.faction) + 1) % GameData.scores.Length));
			//Debug.Assert (AIGrid.findFleeingPoint (this, gameObject.transform.position, out spawnPoint));
			//Debug.Log ("Spawning at " + spawnPoint);
			//agent.Warp ((QTournamentController.g_SpawnPoints[UnityEngine.Random.Range(0,QTournamentController.g_SpawnPoints.Length)].transform.position));

			float maxDist = 0;
			int index = -1;

			int s_c = QTournamentController.g_SpawnPoints.Length;

			for (int i = 0; i < s_c; ++i) {
				float t_dist = 0;
				int numEnemies = 0;

				/*
				 * Get average dist between spawn points and enemy soldiers
				 */

				for (int j = 0; j < GameData.Factions.Count; ++j) {
					if (GameData.Factions [j].FactionName == thisEntity.faction) {
						continue;
					}

					for (int k = 0; k < GameData.Factions [j].Soldiers.Count; ++k) {
						++numEnemies;
						///for (int n = 0; n < QTournamentController.g_SpawnPoints.Length; ++n) {
						t_dist += Vector3.Distance (GameData.Factions [j].Soldiers [k].centreOfMass.position, QTournamentController.g_SpawnPoints[i].transform.position);
						//}
					}
				}


				t_dist /= numEnemies;

				if (t_dist > maxDist) {
					maxDist = t_dist;
					index = i;
				}

			}

			agent.Warp ((QTournamentController.g_SpawnPoints[index].transform.position));

			this.ResetSoldier ();
		}

		/// <summary>
		/// Method to be used as event for when agent is damaged
		/// </summary>
		/// <param name="healthController">Health controller.</param>
		/// <param name="damage">Damage.</param>
		/// <param name="factionThatFiredShot">Faction that fired shot.</param>
		/// <param name="shotDirection">Shot direction.</param>
		public bool OnDamage(ControlHealth healthController, float damage, FactionName factionThatFiredShot, Vector3 shotDirection){
			if (healthController.health <= 0) {
				Debug.Assert (GameData.scores.ContainsKey (factionThatFiredShot));
				++GameData.scores [factionThatFiredShot];
				Respawn ();
			}
			return false;
		}

		/// <summary>
		/// Get number of ongoing actions e.g. reloading
		/// </summary>
		/// <returns>number of actions soldier is busy with</returns>
		public override int GetBusyWithAction ()
		{
			return numActionsBusyWith;
		}

		/// <summary>
		/// Resets state of soldier
		/// of the script
		/// </summary>
		public void ResetSoldier(){
			previousPos = gameObject.transform.position;
			healthController.health = healthController.maxhealth;
			this.CurrentTarget = null;
			this.weapon.magazines = new List<int>{ weapon.magSize, weapon.magSize, weapon.magSize };
			exploring = false;
			agent.ResetPath ();
			numActionsBusyWith = 0;
			currentActionSet.Clear ();
		}
	}
}

