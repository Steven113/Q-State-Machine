//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;


namespace AssemblyCSharp
{
	public class PathFindingNode : IComparable<PathFindingNode>
	{
		public Vector3 pos = Vector3.down;
		public PathFindingNode previous = null;
		public float g = 0;
		public float f = 0;

		public PathFindingNode (PathFindingNode previous, Vector3 pos, Vector3 start, Vector3 end, ref bool reachedEnd, bool useStandardAStar)
		{
			reachedEnd = false;
			this.previous = previous;
			this.pos = pos;

			//we calculate h first, because we can determine when calculating h whether the end is visible, and therefore jump to it
			Vector3 startEndDir = (end - pos);
			
			//float h = startEndDir.magnitude;
			float h = AIGrid.GetManhattanDistance (end, pos);

			startEndDir = startEndDir.normalized;
			
			float dot = -1;
			int dirToUse = -1;
			for (int i = 0; i<AIGrid.LOSDirections.Length; ++i) {
				float temp = Vector3.Dot(startEndDir,AIGrid.LOSDirections[i]);
				if (temp>dot){
					dot = temp;
					dirToUse = i;
				}
			}


			if (dot==1 && AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, dirToUse] >= h) {
				Debug.DrawRay(pos,AIGrid.LOSDirections[dirToUse]*AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, dirToUse],Color.black,30f);
				Debug.DrawRay(pos,startEndDir*AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, dirToUse],Color.magenta,30f);
				Debug.Log("Found jump point!");
				pos = end;
				reachedEnd = true;
			}

			if (!reachedEnd) {
				if (!useStandardAStar){
					if (h>AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, dirToUse]){
						float multiplier = (h/(AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, dirToUse] /** dot*/));

						//multiplier = multiplier<2?multiplier:2; //experimenatlly disabled
						multiplier = multiplier<1?1:multiplier; //experimenatlly disabled
						h*=multiplier;
					}
				}

				if (previous != null) {
					Debug.DrawRay(pos,previous.pos-pos, useStandardAStar?Color.blue:Color.red,10f);
					g = Vector2.Distance (previous.pos, pos) + previous.g;
				}

				//Debug.DrawRay(pos,Vector3.up*h,Color.cyan);

				f = g+h;
				//InitWorldGrid.fValues [(int)pos.x, (int)pos.y] = f;
			}




		}

		public int CompareTo(PathFindingNode other){
			if (Mathf.Approximately (this.f, other.f)) {
				return 0;
			} else if (this.f < other.f) {
				return -1;
			} else {
				return 1;
			}
		}
	}
}

