//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;


namespace AssemblyCSharp
{
	public class PathFindingNode : IComparable<PathFindingNode>
	{
		public Vector3 pos = Vector3.down;
		public PathFindingNode previous = null;
		public float g = 0;
		public float f = 0;
		public float h = 0;
		public float []  losDistance = new float[5];
		public float deltaLosDistance = 0;
		public float deltaH = 0;
		public bool isJumpPoint = false;

		public PathFindingNode (PathFindingNode previous, Vector3 pos, Vector3 start, Vector3 end, ref bool reachedEnd, bool useStandardAStar, bool isJumpPoint)
		{
			this.isJumpPoint = isJumpPoint;
			reachedEnd = false;
			this.previous = previous;
			this.pos = pos;

			//we calculate h first, because we can determine when calculating h whether the end is visible, and therefore jump to it
			Vector3 startEndDir = (end - pos);
			
			h = startEndDir.sqrMagnitude;
			//h = h*(h/AIGrid.GetManhattanDistance (end, pos));
			//h = AIGrid.GetDeltaMax (start, end, 1.44f, 1f);

			startEndDir = startEndDir.normalized;
			
			float dot = -1;
			int dirToUse = -1;

			//get which cardinal direction best matches direction from node to dest
			for (int i = 0; i<AIGrid.LOSDirections.Length; ++i) {
				float temp = Vector3.Dot(startEndDir,AIGrid.LOSDirections[i]);
				if (temp>dot){
					dot = temp;
					dirToUse = i;
				}
			}

			//collect LOS distance both to dest and for angles to the left and right of the direction to dest.
			losDistance [0] = AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, (dirToUse) % AIGrid.LOSDirections.Length];
			losDistance [1] = AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, (dirToUse+1) % AIGrid.LOSDirections.Length];// 45 deg right
			losDistance [2] = AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, (dirToUse+7) % AIGrid.LOSDirections.Length]; //45 degrees left
			losDistance [3] = AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, (dirToUse+2) % AIGrid.LOSDirections.Length]; //90 deg right
			losDistance [4] = AIGrid.visibilityDistances [(int)pos.x, (int)pos.y, (dirToUse+6) % AIGrid.LOSDirections.Length]; //90 deg left

			//if the direction to the dest is exactly parallel to a cardinal direction and we have LOS to the dest, we can skip to the dest
			if (dot==1 && losDistance[0] >= h*dot) {
				Debug.DrawRay(pos,AIGrid.LOSDirections[dirToUse]*losDistance[0],Color.black,30f);
				Debug.DrawRay(pos,startEndDir*losDistance[0],Color.magenta,30f);
				Debug.Log("Found jump point!");
				pos = end;
				reachedEnd = true;
			}

			if (!reachedEnd) {

				if (previous != null) {
					Debug.DrawRay(pos,previous.pos-pos, useStandardAStar?Color.blue:Color.red,10f);
					g = Vector2.Distance (previous.pos, pos) + previous.g;
					//losDistance-=previous.losDistance;
				}

				if (!useStandardAStar){

				}



				//Debug.DrawRay(pos,Vector3.up*deltaH,Color.cyan);

				f = g+h;

			}




		}

		public int CompareTo(PathFindingNode other){
			if (Mathf.Approximately (this.f, other.f)) {
				return 0;
			} else if (this.f < other.f) {
				return -1;
			} else {
				return 1;
			}
		}
	}
}

