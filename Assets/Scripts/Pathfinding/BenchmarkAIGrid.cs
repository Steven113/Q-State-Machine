//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using AssemblyCSharp;
using System.Collections.ObjectModel;
using System.Collections.Generic;


namespace AssemblyCSharp
{
	public class BenchmarkAIGrid : MonoBehaviour
	{

		public static int worldWidth = 100;
		public static int worldHeight = 100;
		public int t_worldWidth = 100;
		public int t_worldHeight = 100;
		public static Vector3[] LOSDirections = null;
		public static Vector3[] SearchDirectionOffsets = null; //to make the code more reusable, when expanding in the 8 cardinal directions we just add these values to the current node position
		public static float[] SearchDirectionDistances = null;
		public static Vector3 worldCentre = Vector3.zero;
		
		public static Vector3[] corners = new Vector3[4];
		public static Vector3[] directionToSearchForNewCorner = new Vector3[4]; //if the corner is blocked, when finding a fleeing path, the pathfinder looks in this direction for a node near the corner that is unblocked
		
		public static bool[][] cellCanBeMovedThrough = new bool[0][];
		public static bool[][] cellExplored = new bool[0][];
		public static int[][] cellExploredBitMask = new int[0][];
		public static float[][] fValues = new float[0][];
		public static float[][] gValues = new float[0][];
		public static float[][] rhsValues = new float[0][];
		public static float[][] numUses = new float[0][];
		public static int s_cellWidth = 0;
		public int cellWidth = 1;

		
		public static float numPathFindingSearches = 0;

		public static int bitMaskWidth = 0;

		// Use this for initialization
		void Awake ()
		{

			worldWidth = t_worldWidth;
			worldHeight = t_worldHeight;

			s_cellWidth = cellWidth;
			Debug.Assert (s_cellWidth > 0);
			LOSDirections = new Vector3[] {
				Vector3.left,
				(Vector3.left + Vector3.forward),
				Vector3.forward,
				(Vector3.right + Vector3.forward),
				Vector3.right,
				(Vector3.right + Vector3.back),
				Vector3.back,
				(Vector3.left + Vector3.back)
			}; //cardinalDirections
			SearchDirectionOffsets = new Vector3[]{
				Vector3.left,
				Vector3.left + Vector3.forward,
				Vector3.forward,
				Vector3.right + Vector3.forward, 
				Vector3.right,
				Vector3.right + Vector3.back,
				Vector3.back,
				Vector3.back + Vector3.left
			};
			
			SearchDirectionDistances = new float[8];
			
			for (int i = 0; i<SearchDirectionDistances.Length; ++i) {
				SearchDirectionDistances [i] = Vector3.Magnitude (SearchDirectionOffsets [i]);
			}
			
			cellCanBeMovedThrough = new bool[worldWidth][];
			for (int i = 0; i<worldWidth; ++i) {
				cellCanBeMovedThrough[i] = new bool[worldHeight];
			}

			cellExplored= new bool[worldWidth][];
			for (int i = 0; i<worldWidth; ++i) {
				cellExplored[i] = new bool[worldHeight];
			}

			cellExploredBitMask = new int[worldWidth][];
			bitMaskWidth = worldHeight / 8 + 1; //want to avoid many repeated divisions!
			for (int i = 0; i<worldWidth; ++i) {
				cellExploredBitMask[i] = new int[bitMaskWidth];
			}
			
			for (int i = 0; i<worldWidth; ++i) {
				for (int j = 0; j<worldHeight; ++j) {
					cellCanBeMovedThrough [i][j] = true;
				}
			}
			fValues = new float[worldWidth][];
			gValues = new float[worldWidth][];
			rhsValues = new float[worldWidth][];
			numUses = new float[worldWidth][];

			fValues = new float[worldWidth][];
			for (int i = 0; i<worldWidth; ++i) {
				fValues[i] = new float[worldHeight];
			}

			gValues = new float[worldWidth][];
			for (int i = 0; i<worldWidth; ++i) {
				gValues[i] = new float[worldHeight];
			}

			rhsValues = new float[worldWidth][];
			for (int i = 0; i<worldWidth; ++i) {
				rhsValues[i] = new float[worldHeight];
			}

			numUses = new float[worldWidth][];
			for (int i = 0; i<worldWidth; ++i) {
				numUses[i] = new float[worldHeight];
			}

			for (int i = 0; i<worldWidth; ++i) {
				for (int j = 0; j<worldHeight; ++j) {
					fValues [i][j] = float.PositiveInfinity / 100;
					fValues [i][j] = float.PositiveInfinity / 100;
					
					gValues [i][j] = float.PositiveInfinity / 100;
					gValues [i][j] = float.PositiveInfinity / 100;
					
					rhsValues [i][j] = float.PositiveInfinity / 100;
					rhsValues [i][j] = float.PositiveInfinity / 100;
					
					//Debug.Log(i + " " + j);
					numUses[i][j] = UnityEngine.Random.Range(0f,1f);
					
					cellCanBeMovedThrough [i][j] = true;
				}
			}
			
			corners [0] = Vector3.zero;
			corners [1] = new Vector3 (1, 0, worldHeight-2);
			corners [2] = new Vector3 (worldWidth-2, 0, 1);
			corners [3] = new Vector3 (worldWidth-2, 0, worldHeight-2);
			
			directionToSearchForNewCorner [0] = Vector3.right;
			directionToSearchForNewCorner [1] = Vector3.back;
			directionToSearchForNewCorner [2] = Vector3.left;
			directionToSearchForNewCorner [3] = Vector3.back;
			
		}
		
		void Start ()
		{
			//don't need to calculate visibility distances
//			for (int i = 0; i<cellCanBeMovedThrough.GetLength(0); ++i) {
//				for (int j = 0; j<cellCanBeMovedThrough.GetLength(1); ++j) {
//					
//					for (int k = 0; k<LOSDirections.Length; ++k) {
//						
//						if (cellCanBeMovedThrough [i][j]) {
//							//Debug.DrawRay(new Vector3(i*cellWidth,0,j*cellWidth),Vector3.forward*cellWidth,Color.red,3f);
//							//Debug.DrawRay(new Vector3(i*cellWidth,0,j*cellWidth),Vector3.right*cellWidth,Color.red,3f);
//							Vector3 losPos = new Vector3 (i, 0, j);
//							losPos += LOSDirections [k];
//							while (((int)losPos.x>=0 && (int)losPos.x<cellCanBeMovedThrough.GetLength(0) && (int)losPos.z>=0 && (int)losPos.z<cellCanBeMovedThrough.GetLength(1)) && cellCanBeMovedThrough[(int)losPos.x,(int)losPos.z]) {
//
//								losPos += LOSDirections [k];
//							}
//							//visibilityDistances [i, j, k] = visibilityDistances [i, j, k] > 0 ? visibilityDistances [i, j, k] : cellWidth;
//						} else {
//
//						}
//					}
//					//}
//				}
//			}
			
			for (int i = 0; i<worldWidth; ++i) {
				for (int j = 0; j<worldHeight; ++j) {
					
					if (cellCanBeMovedThrough [i][j]) {
						Debug.DrawRay (new Vector3 (i * s_cellWidth, 0, j * s_cellWidth), Vector3.forward * s_cellWidth, Color.green, 100f);
						Debug.DrawRay (new Vector3 (i * s_cellWidth, 0, j * s_cellWidth), Vector3.right * s_cellWidth, Color.green, 100f);
					} else {
						Debug.DrawRay (new Vector3 (i * s_cellWidth, 0, j * s_cellWidth), Vector3.forward * s_cellWidth, Color.black, 100f);
						Debug.DrawRay (new Vector3 (i * s_cellWidth, 0, j * s_cellWidth), Vector3.right * s_cellWidth, Color.black, 100f);
					}
					
				}
			}
		}
		// Update is called once per frame
		void Update () {
			//t_heuristicMultiplierAdaptionRate = PathFindingNode.heuristicMultiplier;
			//t_heuristicMultiplier = PathFindingNode.heuristicMultiplier;
		}
		

		
		/*for performance tests*/
		public static bool findPath_Num_Uses(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			

			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						//Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));
					
					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
						
						
						if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
							reachedEnd = true;
							return true;
						}
						
						//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
						bool validPos = false;
						//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
						PathFindingNode node = null;
						//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
						
						
						
							newPos = temp.pos + SearchDirectionOffsets [i];
						if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
							validPos = true;
							node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
						
						
						
						//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
						//								break;
						//							}
						
							if (numUses [(int)newPos.x][(int)newPos.z] < numPathFindingSearches || fValues [(int)newPos.x][(int)newPos.z] > node.f) {
								numUses [(int)newPos.x][(int)newPos.z] = numPathFindingSearches;
							fValues [(int)newPos.x][(int)newPos.z] = node.f;
								gValues [(int)newPos.x][(int)newPos.z] = node.g;
							openList.Add (node);
							++numExpansions;
						}
							}

						}
						
						openList.Remove (temp);

						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();
					
					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					Debug.Log ("OpenList empty");
					return false;
				} else {
					Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				Debug.Log ("Start out of bounds");
				return false;
			}

			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}

		/*for performance tests*/
		public static bool findPath_Bool_Per_Cell(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			
			
			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						//Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));
					
					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
							
							
							if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
								AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
								reachedEnd = true;
								for (int n = 0; n<worldWidth; ++n) {
									for (int j = 0; j<worldHeight; ++j){
										cellExplored[n][j] = false;
									}
								}
								return true;
							}
							
							//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							bool validPos = false;
							//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
							PathFindingNode node = null;
							//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
							
							
							
							newPos = temp.pos + SearchDirectionOffsets [i];
							if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
								validPos = true;
								node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
							
							
							
							//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
							//								break;
							//							}
							
							if (!cellExplored[(int)newPos.x][(int)newPos.z] || fValues [(int)newPos.x][(int)newPos.z] > node.f) {
								cellExplored [(int)newPos.x][(int)newPos.z] = true;
								fValues [(int)newPos.x][(int)newPos.z] = node.f;
								gValues [(int)newPos.x][(int)newPos.z] = node.g;
								openList.Add (node);
								++numExpansions;
							}
							}
							
						}
						
						openList.Remove (temp);
						
						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();

					for (int i = 0; i<worldWidth; ++i) {
						for (int j = 0; j<worldHeight; ++j){
							cellExplored[i][j] = false;
						}
					}

					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					Debug.Log ("OpenList empty");
					return false;
				} else {
					Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				Debug.Log ("Start out of bounds");
				return false;
			}
			
			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}

		/*for performance tests*/
		public static bool findPath_Bool_Per_Cell_Keep_List(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			
			
			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						//Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					Collection<Vector3> closedList = new Collection<Vector3>();
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));

					cellExplored[(int)start.x][(int)start.z] = false;

					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
							
							
							if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
								AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
								reachedEnd = true;
								Vector3 [] closedList_Arr = new Vector3[closedList.Count];
								closedList.CopyTo(closedList_Arr,0);
								float closedList_Arr_L = closedList_Arr.Length;
								for (int k = 0; k<closedList_Arr_L; ++k){
									cellExplored[(int)closedList_Arr[k].x][(int)closedList_Arr[k].z] = false;
								}

								return true;
							}
							
							//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							bool validPos = false;
							//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
							PathFindingNode node = null;
							//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
							
							
							
							newPos = temp.pos + SearchDirectionOffsets [i];
							if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
								validPos = true;
								node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
								
								
								
								//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
								//								break;
								//							}
								
								if (!cellExplored[(int)newPos.x][(int)newPos.z] || fValues [(int)newPos.x][(int)newPos.z] > node.f) {
									cellExplored [(int)newPos.x][(int)newPos.z] = true;
									fValues [(int)newPos.x][(int)newPos.z] = node.f;
									gValues [(int)newPos.x][(int)newPos.z] = node.g;
									openList.Add (node);
									++numExpansions;
									closedList.Add(newPos);
								}
							}
							
						}
						
						openList.Remove (temp);
						
						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();
					
					Vector3 [] closedList_Arr_Alt = new Vector3[closedList.Count];
					closedList.CopyTo(closedList_Arr_Alt,0);
					float closedList_Arr_Alt_L = closedList_Arr_Alt.Length;
					for (int k = 0; k<closedList_Arr_Alt_L; ++k){
						cellExplored[(int)closedList_Arr_Alt[k].x][(int)closedList_Arr_Alt[k].z] = false;
					}
					
					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					Debug.Log ("OpenList empty");
					return false;
				} else {
					Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				Debug.Log ("Start out of bounds");
				return false;
			}
			
			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}

		/*for performance tests*/
		public static bool findPath_Bit_Mask(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			
			
			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));
					
					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
							
							
							if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
								AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
								reachedEnd = true;
								for (int n = 0; n<worldWidth; ++n) {
									for (int j = 0; j<bitMaskWidth; ++j){
										cellExploredBitMask[n][j] = 0;
									}
								}
								return true;
							}
							
							//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							bool validPos = false;
							//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
							PathFindingNode node = null;
							//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
							
							
							
							newPos = temp.pos + SearchDirectionOffsets [i];
							if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
								validPos = true;
								node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
							
							
							
							//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
							//								break;
							//							}
							
								int numBytesToShift  = (int)(newPos.z/32);
								int numBitsToShift = (int)(newPos.z%worldHeight);

								if (0==(cellExploredBitMask[(int)newPos.x][numBytesToShift] & (1<< numBitsToShift)) || fValues [(int)newPos.x][(int)newPos.z] > node.f) {
								cellExploredBitMask[(int)newPos.x][numBytesToShift] = (cellExploredBitMask[(int)newPos.x][numBytesToShift] | (1<< numBitsToShift));
								fValues [(int)newPos.x][(int)newPos.z] = node.f;
								gValues [(int)newPos.x][(int)newPos.z] = node.g;
								openList.Add (node);
								++numExpansions;
							}
							}
							
						}
						
						openList.Remove (temp);
						
						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();
					
					for (int i = 0; i<worldWidth; ++i) {
						for (int j = 0; j<bitMaskWidth; ++j){
							cellExploredBitMask[i][j] = 0;
						}
					}
					
					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					Debug.Log ("OpenList empty");
					return false;
				} else {
					Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				Debug.Log ("Start out of bounds");
				return false;
			}
			
			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}

		/*for performance tests*/
		public static bool findPath_Bit_Mask_Keep_List(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			
			
			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));

					cellExploredBitMask[(int)(start.x/32)][(int)(start.z/32)] = 0;

					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					Collection<Vector3> closedList = new Collection<Vector3>();
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
							
							
							if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
								AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
								reachedEnd = true;
								Vector3 [] closedList_Arr = new Vector3[closedList.Count];
								closedList.CopyTo(closedList_Arr,0);
								
								int closedList_Arr_L = closedList_Arr.Length;
								
								for (int k = 0; k<closedList_Arr_L; ++k){
									cellExploredBitMask[(int)(closedList_Arr[k].x)][(int)(closedList_Arr[k].z/32)] = 0;
								}
								return true;
							}
							
							//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							bool validPos = false;
							//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
							PathFindingNode node = null;
							//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
							
							
							
							newPos = temp.pos + SearchDirectionOffsets [i];
							if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
								validPos = true;
								node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
								
								
								
								//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
								//								break;
								//							}
								
								int numBytesToShift  = (int)(newPos.z/32);
								int numBitsToShift = (int)(newPos.z%worldHeight);
								
								if (0==(cellExploredBitMask[(int)newPos.x][numBytesToShift] & (1<< numBitsToShift)) || fValues [(int)newPos.x][(int)newPos.z] > node.f) {
									cellExploredBitMask[(int)newPos.x][numBytesToShift] = (cellExploredBitMask[(int)newPos.x][numBytesToShift] | (1<< numBitsToShift));
									fValues [(int)newPos.x][(int)newPos.z] = node.f;
									gValues [(int)newPos.x][(int)newPos.z] = node.g;
									openList.Add (node);
									closedList.Add(newPos);
									++numExpansions;
								}
							}
							
						}
						
						openList.Remove (temp);
						
						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();
					
					Vector3 [] closedList_Arr_Alt = new Vector3[closedList.Count];
					closedList.CopyTo(closedList_Arr_Alt,0);

					int closedList_Arr_Alt_L = closedList_Arr_Alt.Length;

					for (int k = 0; k<closedList_Arr_Alt_L; ++k){
						cellExploredBitMask[(int)(closedList_Arr_Alt[k].x)][(int)(closedList_Arr_Alt[k].z/32)] = 0;
					}

					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					Debug.Log ("OpenList empty");
					return false;
				} else {
					Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				Debug.Log ("Start out of bounds");
				return false;
			}
			
			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}


		/*for performance tests*/
		public static bool findPath_Sorted_Closed_List(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			
			
			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						//Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					NodeList<PathFindingNode> closedList = new NodeList<PathFindingNode> ();
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));
					
					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
							
							
							if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
								AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
								reachedEnd = true;

								return true;
							}
							
							//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							bool validPos = false;
							//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
							PathFindingNode node = null;
							//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
							
							
							
							newPos = temp.pos + SearchDirectionOffsets [i];
							if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
								validPos = true;
								node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
							
							
							
							//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
							//								break;
							//							}
							
							if (!closedList.ContainsMemberWithLowerCost(node) || fValues [(int)newPos.x][(int)newPos.z] > node.f) {

								fValues [(int)newPos.x][(int)newPos.z] = node.f;
								gValues [(int)newPos.x][(int)newPos.z] = node.g;
								openList.Add (node);
								++numExpansions;
							}
							}
						}
						
						openList.Remove (temp);
						closedList.Add(temp);
						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();
					
					for (int i = 0; i<worldWidth; ++i) {
						for (int j = 0; j<worldHeight; ++j){
							cellExplored[i][j] = false;
						}
					}
					
					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					Debug.Log ("OpenList empty");
					return false;
				} else {
					Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				Debug.Log ("Start out of bounds");
				return false;
			}
			
			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}

		/*for performance tests*/
		public static bool findPath_Closed_List_Unsorted(Vector3 start, Vector3 end, out Collection<Vector3> path, bool useStandardAStar = true)
		{
			path = new Collection<Vector3>();
			++numPathFindingSearches;
			//float timeToRun = System.DateTime.Now.Ticks;
			
			
			++numPathFindingSearches;
			//path = new Collection<Vector3> ();
			//first check that start and end are within bounds
			bool keepSearching = true;
			if (start.x >= 0 && start.x < worldWidth && start.z >= 0 && start.z < worldHeight) {
				if (end.x >= 0 && end.x < worldWidth && end.z >= 0 && end.z < worldHeight) {
					if (!cellCanBeMovedThrough [(int)end.x][(int)end.z]) {
						//Debug.Log ("Cannot move to destination cell");
						return false;
					}
					
					
					
					NodeList<PathFindingNode> openList = new NodeList<PathFindingNode> ();
					Collection<PathFindingNode> closedList = new Collection<PathFindingNode>(); 
					bool reachedEnd = false;
					openList.Add (new PathFindingNode (null, start, start, end, ref reachedEnd, useStandardAStar, false));


					int numIter = 0;
					int maxNumIter = int.MaxValue;;
					int numExpansions = 0;
					PathFindingNode temp = openList [0];
					//gValues [(int)(temp.pos.x), (int)(temp.pos.z), useStandardAStar ? 0 : 1] = 0;
					while (openList.Count>0 && !reachedEnd) {
						float startTime = Time.realtimeSinceStartup;
						++numIter;
						if (numIter > maxNumIter) {
							Debug.Log ("NMMT");
							break;
						}
						temp = openList [0];
						
						bool consistent = false;
						
						Vector3 newPos = temp.pos;
						
						for (int i = 0; i<8; ++i){
							
							
							if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
								AIGrid.CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
								reachedEnd = true;
								
								return true;
							}
							
							//if ((int)newPos.x == (int)end.x && (int)newPos.z == (int)end.z) {
							bool validPos = false;
							//if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x, (int)newPos.z]) {
							PathFindingNode node = null;
							//jump search when using LOS*. We attempt to exponentially increase the jump distance, to reduce the expansion amount
							
							
							
							newPos = temp.pos + SearchDirectionOffsets [i];
							if ((int)newPos.x >= 0 && (int)newPos.x < worldWidth && (int)newPos.z >= 0 && (int)newPos.z < worldHeight && cellCanBeMovedThrough [(int)newPos.x][(int)newPos.z]) {
								validPos = true;
								node = new PathFindingNode (temp, newPos, start, end, ref reachedEnd, useStandardAStar, false);
							
							
							
							//							if (reachedEnd) { //adding to the openlist is expensive, and we've found the end, so we break now
							//								break;
							//							}

							bool betterNodeExists = false;
							PathFindingNode [] temp_CL = new PathFindingNode[closedList.Count];
							closedList.CopyTo(temp_CL,0);

							float temp_CL_Length = temp_CL.Length;

							for (int n = 0; n<temp_CL_Length; ++n){
								if (temp_CL[n].pos.x == node.pos.x && temp_CL[n].pos.z == node.pos.z && node.f>temp_CL[n].f){
									betterNodeExists = true;
									break;
								}
							}


							if (!betterNodeExists || fValues [(int)newPos.x][(int)newPos.z] > node.f) {
								
								fValues [(int)newPos.x][(int)newPos.z] = node.f;
								gValues [(int)newPos.x][(int)newPos.z] = node.g;
								openList.Add (node);
								++numExpansions;
							}
							}
						}
						
						openList.Remove (temp);
						closedList.Add(temp);
						//timeToRun += (endTime-startTime);
						//yield return new WaitForSeconds (0.01f);
					}
					//path = new Collection<Vector3> ();
					
					for (int i = 0; i<worldWidth; ++i) {
						for (int j = 0; j<worldHeight; ++j){
							cellExplored[i][j] = false;
						}
					}
					
					////if (temp != null) {
					//	CreatePath (temp, ref path, start, end, true, useStandardAStar, false, useStandardAStar ? Color.green : Color.magenta, 30f);
					//}
					//Debug.Log ((useStandardAStar ? "AStar" : "LOS*") + " Expansions: " + numExpansions + " " + reachedEnd + " " + timeToRun);
					//Debug.Log ("OpenList empty");
					return false;
				} else {
					//Debug.Log ("End out of bounds");
					return false;
				}
			} else {
				//Debug.Log ("Start out of bounds");
				return false;
			}
			
			//MonoBehaviour.StartCoroutine (start, end, !useStandardAStar);
		}

	}
}

